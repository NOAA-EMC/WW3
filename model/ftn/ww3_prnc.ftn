MODULE c_caldat
CONTAINS
!*********************************************************************
INTEGER FUNCTION julday(id,mm,iyyy)
! See numerical recipes 2nd ed. The order of month and day have been swapped!
!*********************************************************************
   IMPLICIT NONE
        INTEGER(KIND=4),    INTENT(in)  :: id,mm,iyyy
   INTEGER(KIND=4), PARAMETER :: IGREG=15+31*(10+12*1582)
   INTEGER(KIND=4) ja,jm,jy
   jy=iyyy
   IF (jy.EQ.0) WRITE(6,*) 'There is no zero year !!'
   IF (jy.LT.0) jy=jy+1
   IF (mm.GT.2) THEN
      jm=mm+1
   ELSE
      jy=jy-1
      jm=mm+13
   ENDIF
   julday=INT(365.25*jy)+int(30.6001*jm)+id+1720995
   IF (id+31*(mm+12*iyyy).GE.IGREG) THEN
      ja=INT(0.01*jy)
      julday=julday+2-ja+INT(0.25*ja)
   ENDIF
   RETURN
END FUNCTION JULDAY

!*********************************************************************
SUBROUTINE caldat(julian,id,mm,iyyy)
! See numerical recipes 2nd ed. The order of month and day have been swapped!
!*********************************************************************
   IMPLICIT NONE
        INTEGER(KIND=4),    INTENT(in)  :: julian
   INTEGER(KIND=4),    INTENT(out) :: id,mm,iyyy
   INTEGER(KIND=4), PARAMETER :: IGREG=2299161
   INTEGER(KIND=4) ja,jalpha,jb,jc,jd,je
   if (julian.GE.IGREG) THEN
      jalpha=INT(((julian-1867216)-0.25)/36524.25)
      ja=julian+1+jalpha-INT(0.25*jalpha)
   ELSE
      ja=julian
   ENDIF
   jb=ja+1524
   jc=INT(6680.+((jb-2439870)-122.1)/365.25)
   jd=365*jc+INT(0.25*jc)
   je=INT((jb-jd)/30.6001)
   id=jb-jd-INT(30.6001*je)
   mm=je-1
   IF (mm.GT.12) mm=mm-12
   iyyy=jc-4715
   IF (mm.GT.2) iyyy=iyyy-1
   IF (iyyy.LE.0) iyyy=iyyy-1
   RETURN
   END SUBROUTINE CALDAT
END MODULE c_caldat
!*********************************************************************



!/ ------------------------------------------------------------------- /
      PROGRAM W3PRNC
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           M. Accensi              |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         17-Nov-2011 |
!/                  +-----------------------------------+
!/
!/    01-Jan-2011 : Creation                            ( version 4.01 )   
!/    17-Nov-2011 : Fix bug on latitudes                ( version 4.04 )

!/
!/    Copyright 2009 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     Pre-processing of the input water level, current, wind and ice
!     fields as well as assimilation data ... from NetCDF input       
!
!  2. Method :
!
!     See documented input file.
!
!  3. Parameters :
!
!     Local parameters.
!     ----------------------------------------------------------------
!       NDSI    Int.  Input unit number ("ww3_prep.inp").
!       NDSLL   Int.  Unit number(s) of long-lat file(s)
!       NDSF    I.A.  Unit number(s) of input file(s).
!       NDSDAT  Int.  Unit number for output data file.
!       IFLD    Int.  Integer input type.
!       ITYPE   Int.  Integer input 'format' type.
!       NFCOMP  Int.  Number of partial input to be processed.
!       FLTIME  Log.  Time flag for input fields, if false, single
!                     field, time read from NDSI.
!       IDLALL  Int.  Layout indicator used by INA2R. +
!       IDFMLL  Int.  Id. FORMAT indicator.           |
!       FORMLL  C*16  Id. FORMAT.                     | Long-lat
!       FROMLL  C*4   'UNIT' / 'NAME' indicator       |    file(s)
!       NAMELL  C*20  Name of long-lat file(s)        +
!       IDLAF   I.A.   +
!       IDFMF   I.A.   |
!       FORMF   C.A.   | Idem. fields file(s)
!       FROMF   C*4    |
!       NAMEF   C*20   +
!       FORMT   C.A.  Format or time in field.
!       XC      R.A.  Components of input vector field or first
!                     input scalar field
!       YC      R.A.  Components of input vector field or second
!                     input scalar field
!       FX,FY   R.A.  Output fields.
!       ACC     Real  Required interpolation accuracy.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3NMOD    Subr. W3GDATMD Set number of model.
!      W3SETG    Subr.   Id.    Point to selected model.
!      W3NDAT    Subr. W3WDATMD Set number of model for wave data.
!      W3SETW    Subr.   Id.    Point to selected model for wave data.
!      W3NOUT    Subr. W3ODATMD Set number of model for output.
!      W3SETO    Subr.   Id.    Point to selected model for output.
!      ITRACE    Subr. W3SERVMD Subroutine tracing initialization.
!      STRACE    Subr.   Id.    Subroutine tracing.
!      NEXTLN    Subr.   Id.    Get next line from input filw
!      EXTCDE    Subr.   Id.    Abort program as graceful as possible.
!      STME21    Subr. W3TIMEMD Convert time to string.
!      INAR2R    Subr. W3ARRYMD Read in an REAL array.
!      INAR2I    Subr.   Id.    Read in an INTEGER array.
!      PRTBLK    Subr.   Id.    Print plot of array.
!      W3IOGR    Subr. W3IOGRMD Reading/writing model definition file.
!      W3FLDO    Subr. W3FLDSMD Opening of WAVEWATCH III generic shell
!                               data file.
!      W3FLDP    Subr.   Id.    Prepare interp. from arbitrary grid.
!      W3FLDG    Subr.   Id.    Reading/writing shell input data.
!      W3FLDD    Subr.   Id.    Reading/writing shell assim. data.
!      W3GSUC    Func. W3GSRUMD Create grid-search-utility object
!      W3GSUD    Subr. W3GSRUMD Destroy grid-search-utility object
!      W3GRMP    Func. W3GSRUMD Compute interpolation weights
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!     None, stand-alone program.
!
!  6. Error messages :
!
!     - Checks on files and reading from file.
!     - Checks on validity of input parameters.
!
!  7. Remarks :
!
!     - Input fields need to be continuous in longitude and latitude.
!
!  8. Structure :
!
!     ----------------------------------------------------
!        1.a  Number of models.
!                   ( W3NMOD , W3NOUT , W3SETG , W3SETO )
!          b  I-O setup.
!          c  Print heading(s).
!        2.   Read model definition file.      ( W3IOGR )
!        3.a  Read major types from input file.
!          b  Check major types.
!          c  Additional input format types and time.
!        4.   Prepare interpolation.
!          a  Longitude - latitude grid
!          b  Grid(s) from file.               ( W3FLDP )
!          c  Initialize fields.
!          d  Input location and format.
!        5    Prepare input and output files.
!          a  Open input file
!          b  Open and prepare output file     ( W3FLDO )
!        6    Until end of file
!          a  Read new time and fields
!          b  Interpolate fields
!          c  Write fields                     ( W3FLDG )
!     ----------------------------------------------------
!
!  9. Switches :
!
!     !/WNT0  = !/WNT1
!     !/WNT1  Correct wind speeds to (approximately) conserve the wind
!             speed over the interpolation box.
!     !/WNT2  Id. energy (USE ONLY ONE !)
!     !/CRT1  Like !/WNT1 for currents.
!     !/CRT2  Like !/WNT2 for currents.
!
!     !/O3    Additional output in fields processing loop.
!     !/O15   Generate file with the times of the processed fields.
!
!     !/S     Enable subroutine tracing.
!     !/T     Enable test output,
!     !/T1    Full interpolation data.
!     !/T1a   Echo of lat-long data in type Fn
!     !/T2    Full input data.
!     !/T3    Print-plot of output data.
!
!     !/NCO   NCEP NCO modifications for operational implementation.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS
!/
!     USE W3GDATMD, ONLY: W3NMOD, W3SETG
!/NL1      USE W3ADATMD,ONLY: W3NAUX, W3SETA
      USE W3ODATMD, ONLY: W3NOUT, W3SETO
      USE W3SERVMD, ONLY : ITRACE, NEXTLN, EXTCDE
!/S      USE W3SERVMD, ONLY : STRACE
      USE W3TIMEMD, ONLY : STME21
      USE W3ARRYMD, ONLY : INA2R, INA2I
!/T2      USE W3ARRYMD, ONLY : PRTBLK
!/T3      USE W3ARRYMD, ONLY : PRTBLK
      USE W3IOGRMD, ONLY: W3IOGR
      USE W3FLDSMD, ONLY: W3FLDO, W3FLDP, W3FLDG, W3FLDD
!/
      USE W3GDATMD
      USE W3GSRUMD
      USE W3ODATMD, ONLY: NDSE, NDST, NDSO, FNMPRE

      USE c_caldat
      USE netcdf
!
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: NTI
      CHARACTER               :: STRFIELDSNAME*1024
      CHARACTER*5             :: FIELDSNAME(50)*30
      INTEGER                 :: NFIELDS

      INTEGER                 :: NDSI, NDSM, NDSDAT, NDSTRC, NTRACE,  &
                                 IERR, IFLD, ITYPE, J, IX, IY, NFCOMP,&
                                 TIME(2), NXI, NYI, NXJ(2), NYJ(2),   &
                                 NDSLL, IDLALL, IDFMLL, NDSF(2),      &
                                 IDLAF(2), IDFMF(2), TIME2(2),        &
                                 MXM, MYM, DATTYP, RECLDT, IDAT,      &
                                 NDAT, NDATMX, JJ, IS(4), JS(4)
      INTEGER                 :: NYB
      INTEGER                 :: ILAND = -999
!/O15      INTEGER                 :: NDSTIME
      INTEGER, ALLOCATABLE    :: IX21(:,:), IX22(:,:),                &
                                 IY21(:,:), IY22(:,:),                &
                                 JX21(:,:), JX22(:,:),                &
                                 JY21(:,:), JY22(:,:), MAPOVR(:,:)
      INTEGER, ALLOCATABLE    :: MASK(:,:)
      TYPE(T_GSU)             :: GSI
!/S      INTEGER, SAVE           :: IENT = 0
!/T2      INTEGER                 :: IXP0, IXPN, IXPWDT = 60
!/T3      INTEGER                 :: IX0, IXN, IXWDT = 60
!/T3      INTEGER, ALLOCATABLE    :: MAPOUT(:,:)
      REAL                    :: X0I, XNI, Y0I, YNI, SXI, SYI, XDIF,  &
                                 ADD, X, Y, FACTOR, EFAC, NODATA, RW(4)
      REAL                    :: ACC = 0.05
      REAL, ALLOCATABLE       :: RD11(:,:), RD21(:,:),                &
                                 RD12(:,:), RD22(:,:),                &
                                 XD11(:,:), XD21(:,:),                &
                                 XD12(:,:), XD22(:,:),                &
                                 FX(:,:), FY(:,:), FA(:,:),           &
                                 A1(:,:), A2(:,:), A3(:,:)
      REAL, POINTER           :: ALA(:,:), ALO(:,:)
      REAL, ALLOCATABLE       :: XC(:,:), YC(:,:), AC(:,:), DATA(:,:)
      LOGICAL                 :: INGRID
      LOGICAL                 :: FLSTAB, FLBERG, CLO(2), FLTIME, FLHDR
      INTEGER                 :: ICLO
!/T      LOGICAL                 :: FLMOD
      CHARACTER               :: COMSTR*1, IDFLD*3, IDTYPE*2,         &
                                 IDTIME*23, FROMLL*4, FORMLL*16,      &
                                 NAMELL*20, FROMF*4, NAMEF*20
      CHARACTER*12            :: IDSTR1(5)
      CHARACTER*15            :: IDSTR3(3)
      CHARACTER*32            :: FORMT(2), FORMF(2)
      CHARACTER*20            :: IDSTR2(5)
      INTEGER                 :: GTYPEDUM = 0
!
      INTEGER               :: ncid, iret, ndims, parents, nvars, natts, varidtmp
      INTEGER, ALLOCATABLE  :: varid(:), dimid(:), dimln(:), varndims(:), vardimids(:,:)
      CHARACTER*10, DIMENSION(:), ALLOCATABLE   :: varname, dimname
      CHARACTER*50          :: timeunits
      DOUBLE PRECISION      :: dateref, datecur
      REAL                  :: scur, mncur, hcur, fillvalue
      INTEGER               :: i,ITIME, dref, mref, yref, dcur, mcur, ycur
      CHARACTER*14          :: TIME_STR


      EQUIVALENCE              ( NXI , NXJ(1) ) , ( NYI , NYJ(1) )
!/
!/ ------------------------------------------------------------------- /
!/
      DATA IDSTR1 / 'ice         ' , 'water levels' ,                 &
                    'winds       ' , 'currents    ' ,                 &
                    'data        ' /
      DATA IDSTR2 / 'pre-processed file  ' , 'long.-lat. grid     ' , &
                    'grid from file (1)  ' , 'grid from file (2)  ' , &
                    'data (assimilation) ' /
      DATA IDSTR3 / 'mean parameters', '1D spectra     ',             &
                    '2D spectra     ' /
!
!/NCO/!     CALL W3TAGB('WAVEPREP',1998,0007,0050,'NP21   ')
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 1.a  Set number of models
!
      CALL W3NMOD ( 1, 6, 6 )
      CALL W3SETG ( 1, 6, 6 )
!/NL1      CALL W3NAUX (    6, 6 )
!/NL1      CALL W3SETA ( 1, 6, 6 )
      CALL W3NOUT (    6, 6 )
      CALL W3SETO ( 1, 6, 6 )
!
! 1.b  IO set-up.
!
      NDSI   = 10
      NDSO   =  6
      NDSE   =  6
      NDST   =  6
      NDSM   = 11
      NDSDAT = 12
!/O15      NDSTIME = 13
!
      NDSTRC =  6
      NTRACE = 10
      CALL ITRACE ( NDSTRC, NTRACE )
!
!/NCO/!
!/NCO/! Redo according to NCO
!/NCO/!
!/NCO      NDSI   = 11
!/NCO      NDSO   =  6
!/NCO      NDSE   = NDSO
!/NCO      NDST   = NDSO
!/NCO      NDSM   = 12
!/NCO      NDSDAT = 51
!/NCO      NDSTRC = NDSO
!
! 1.c Print header
!
      WRITE (NDSO,900)
!/S      CALL STRACE (IENT, 'W3PRNC')
!
      J      = LEN_TRIM(FNMPRE)
      OPEN (NDSI,FILE=FNMPRE(:J)//'ww3_prnc.inp',STATUS='OLD',ERR=800,IOSTAT=IERR)
      REWIND (NDSI)
      READ (NDSI,'(A)',END=801,ERR=802,IOSTAT=IERR) COMSTR
      IF (COMSTR.EQ.' ') COMSTR = '$'
      WRITE (NDSO,901) COMSTR
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 2.  Read model definition file.
!
      CALL W3IOGR ( 'READ', NDSM )
      WRITE (NDSO,902) GNAME
      ALLOCATE ( IX21(NX,NY), IX22(NX,NY), IY21(NX,NY), IY22(NX,NY),  &
                 JX21(NX,NY), JX22(NX,NY), JY21(NX,NY), JY22(NX,NY),  &
                 MAPOVR(NX,NY) )
      ALLOCATE ( RD11(NX,NY), RD21(NX,NY), RD12(NX,NY), RD22(NX,NY),  &
                 XD11(NX,NY), XD21(NX,NY), XD12(NX,NY), XD22(NX,NY),  &
                 FX(NX,NY), FY(NX,NY), FA(NX,NY),                     &
                 A1(NX,NY), A2(NX,NY), A3(NX,NY) )
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 3.a Read types and variables from input file.
!
      CALL NEXTLN ( COMSTR , NDSI , NDSE )
      READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) IDFLD, IDTYPE, FLTIME, FLHDR
!
! 3.b Check types.
!
      FLSTAB = IDFLD .EQ. 'WNS'
      FLBERG = IDFLD .EQ. 'ISI'
      IF ( IDFLD.EQ.'ICE' .OR. FLBERG ) THEN
          IFLD    = 1
        ELSE IF ( IDFLD.EQ.'LEV' ) THEN
          IFLD    = 2
        ELSE IF ( IDFLD.EQ.'WND' .OR. FLSTAB ) THEN
          IFLD    = 3
        ELSE IF ( IDFLD.EQ.'CUR' ) THEN
          IFLD    = 4
        ELSE IF ( IDFLD.EQ.'DAT' ) THEN
          IFLD    = 5
        ELSE
          WRITE (NDSE,1030) IDFLD
          CALL EXTCDE ( 1 )
        END IF
!
      NFCOMP = 1
      IF (IDFLD.EQ.'DAT') THEN
          ITYPE   = 5
        ELSE IF (IDTYPE.EQ.'AI') THEN
          ITYPE   = 1
        ELSE IF (IDTYPE.EQ.'LL') THEN
          ITYPE   = 2
        ELSE IF (IDTYPE.EQ.'F1') THEN
          ITYPE   = 3
        ELSE IF (IDTYPE.EQ.'F2') THEN
          ITYPE   = 4
          NFCOMP = 2
        ELSE
          WRITE (NDSE,1031) IDTYPE
          CALL EXTCDE ( 2 )
        END IF
!
!/T      IF (ITYPE.NE.1 .AND. ITYPE.NE.5) WRITE (NDST,9000) ACC
!
      WRITE (NDSO,930) IDSTR1(IFLD), IDSTR2(ITYPE)
      IF ( ITYPE.NE.1 ) THEN
!/WNT0          IF (IFLD.EQ.3) WRITE (NDSO,1930)
!/WNT1          IF (IFLD.EQ.3) WRITE (NDSO,1930)
!/WNT2          IF (IFLD.EQ.3) WRITE (NDSO,2930)
!/CRT1          IF (IFLD.EQ.4) WRITE (NDSO,1930)
!/CRT2          IF (IFLD.EQ.4) WRITE (NDSO,2930)
        END IF
      IF ( FLBERG ) WRITE (NDSO,938)
      IF ( FLSTAB ) WRITE (NDSO,939)
!
      CALL NEXTLN ( COMSTR , NDSI , NDSE )
      READ (NDSI,'(A)',END=801,ERR=802,IOSTAT=IERR) STRFIELDSNAME
!
      FIELDSNAME(:)=''
      CALL SPLIT(STRFIELDSNAME,FIELDSNAME)
!
      ! Counts the number of variables
      NFIELDS=0
      DO WHILE (len_trim(FIELDSNAME(NFIELDS+1)).NE.0)
        NFIELDS=NFIELDS+1
      ENDDO


!
! 3.c Additional input for format types and time
! ... time
!
      IF (.NOT. FLTIME) THEN
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) TIME
        IF (TIME(1).LT.10000000) THEN
          WRITE (NDSE,1035) TIME
          CALL EXTCDE ( 4 )
        END IF
        CALL STME21 ( TIME , IDTIME )
        WRITE (NDSO,931) IDTIME
      END IF
!
      J = 1
      IF ( FLAGLL ) THEN
        FACTOR = 1.
      ELSE
        FACTOR = 1.E-3
      END IF

!
! 3.d Read Input netcdf file
!
      CALL NEXTLN ( COMSTR , NDSI , NDSE )
      READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) NAMEF
      WRITE (NDSO,967) NAMEF

      J = LEN_TRIM(FNMPRE)
      iret=nf90_open(path=FNMPRE(:J)//NAMEF,mode=nf90_nowrite,ncid=ncid)
      call check_err(iret)
      ! gets number of dimensions, variables, global attributes
      iret=nf90_inquire(ncid, ndims, nvars, natts)
      call check_err(iret)
      ! gets id of each dimension
      ALLOCATE(dimname(ndims),dimid(ndims),dimln(ndims))
      iret=nf90_inq_dimids(ncid,ndims,dimid,parents)
      call check_err(iret)
      ! gets name and length of each dimension
      DO i=1,ndims
        iret=nf90_inquire_dimension(ncid,dimid(i),name=dimname(i),len=dimln(i))
        call check_err(iret)
      END DO

      ! gets id of each variable
      ALLOCATE(varname(nvars),varid(nvars))
      iret=nf90_inq_varids(ncid,nvars,varid)
      call check_err(iret)

      ! gets name of each variable
      ALLOCATE(varndims(nvars),vardimids(nvars,NF90_MAX_VAR_DIMS))
      DO i=1,nvars
        iret=nf90_inquire_variable(ncid,varid(i),name=varname(i),ndims=varndims(i),dimids=vardimids(i,:))
        call check_err(iret)
      END DO
!
! instanciates time
!
      iret=nf90_inq_varid(ncid,"time",varidtmp)
      call check_err(iret)
      iret=nf90_get_att(ncid,varidtmp,"units",timeunits)
      IF (index(timeunits, "seconds").NE.0) THEN
        read(timeunits(15:18),'(I4.4)') yref
        read(timeunits(20:21),'(I2.2)') mref
        read(timeunits(23:24),'(I2.2)') dref
      ELSE IF (index(timeunits, "days").NE.0) THEN
        read(timeunits(12:15),'(I4.4)') yref
        read(timeunits(17:18),'(I2.2)') mref
        read(timeunits(20:21),'(I2.2)') dref
      END IF
      dateref=julday(dref,mref,yref)
!
! instanciates generic variables dimensions
!
      DO i=1,ndims
        IF (dimname(i) .EQ. "time") NTI = dimln(i)
        IF ((dimname(i) .EQ. "longitude") .OR. (dimname(i) .EQ. "lon") &
                                        .OR. (dimname(i) .EQ. "node")) NXI = dimln(i)
        IF ((dimname(i) .EQ. "latitude") .OR. (dimname(i) .EQ. "lat") &
                                        .OR. (dimname(i) .EQ. "node")) NYI = dimln(i)
      END DO

      ALLOCATE ( ALA(NXI,NYI), ALO(NXI,NYI) )
      iret=nf90_inq_varid(ncid,"longitude",varidtmp)
      IF ( iret/=nf90_noerr ) iret=nf90_inq_varid(ncid,"lon",varidtmp)
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,X0I,start=(/1/))
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,XNI,start=(/NXI/))
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,ALO(:,1))
      call check_err(iret)
      DO i=1,NYI
        ALO(:,i)=ALO(:,1)
      END DO

      iret=nf90_inq_varid(ncid,"latitude",varidtmp)
      IF ( iret/=nf90_noerr ) iret=nf90_inq_varid(ncid,"lat",varidtmp)
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,Y0I, start=(/1/))
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,YNI, start=(/NYI/))
      call check_err(iret)
      iret=nf90_get_var(ncid,varidtmp,ALA(1,:))
      call check_err(iret)
      DO i=1,NXI
        ALA(i,:)=ALA(1,:)
      END DO
!
! gets FillValue
!
      iret=nf90_inq_varid(ncid,FIELDSNAME(1),varidtmp)
      call check_err(iret)
      iret=nf90_get_att(ncid,varidtmp,"_FillValue", fillvalue)
      call check_err(iret)

!
! ... type 1
!
      IF (ITYPE.EQ.1) THEN
!
        NXI    = NX
        NYI    = NY
        ALLOCATE ( MASK(NXI,NYI) )
        MASK   = 1
        IF(GTYPE .EQ. UNGTYPE) THEN
!
!  X0, Y0 are the coordinates of the lower-left point in mesh
!
          RW(1) = FACTOR*X0        ; RW(2) = FACTOR*MAXX
          RW(3) = FACTOR*Y0        ; RW(4) = FACTOR*MAXY
        ELSE
          RW(1) = FACTOR*XGRD(1,1) ; RW(2) = FACTOR*XGRD(NY,NX)
          RW(3) = FACTOR*YGRD(1,1) ; RW(4) = FACTOR*YGRD(NY,NX)
        END IF
        WRITE (NDSO,932) NXI, NYI
        IF ( FLAGLL ) THEN
          WRITE (NDSO,933) RW(1),RW(2),RW(3),RW(4)
        ELSE
          WRITE (NDSO,733) RW(1),RW(2),RW(3),RW(4)
        END IF
!
! ... type 2
!
      ELSE IF (ITYPE.EQ.2) THEN
!
        IF (NXI.LT.2 .OR. NYI.LT.2) THEN
          WRITE (NDSE,1036) NXI, NYI
          CALL EXTCDE ( 5 )
        END IF
        ALLOCATE ( MASK(NXI,NYI) )
        MASK   = 1
        WRITE (NDSO,932) NXI, NYI

        IF ( FLAGLL ) THEN
          WRITE (NDSO,933) FACTOR*X0I, FACTOR*XNI,                &
                           FACTOR*Y0I, FACTOR*YNI
        ELSE
          WRITE (NDSO,733) FACTOR*X0I, FACTOR*XNI,                &
                           FACTOR*Y0I, FACTOR*YNI
        END IF
!
! ... type 5
!
      ELSE IF (ITYPE.EQ.5) THEN
        CALL NEXTLN ( COMSTR , NDSI , NDSE )
        READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR)                   &
              DATTYP, RECLDT, NODATA
        IF (DATTYP.LT.0 .OR. DATTYP.GT.2) THEN
          WRITE (NDSE,1033) DATTYP
          CALL EXTCDE ( 6 )
        END IF
        IF (RECLDT.LE.0) THEN
          WRITE (NDSE,1034) RECLDT
          CALL EXTCDE ( 7 )
        END IF
        WRITE (NDSO,934) IDSTR3(DATTYP+1), RECLDT, NODATA
        WRITE (IDFLD,935) DATTYP
        DEALLOCATE ( IX21, IX22, IY21, IY22, JX21, JX22, JY21, JY22, &
                     MAPOVR )
        DEALLOCATE ( RD11, RD21, RD12, RD22, XD11, XD21, XD12, XD22, &
                     FX, FY, FA, A1, A2, A3 )
!
! ... types 3 and 4 ... in preprocessing loop ....
!
      END IF
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 4   Prepare interpolation.
!
      WRITE (NDSO,940)
!
      IF (ITYPE.NE.1 .AND. ITYPE.NE.5) THEN
!
! 4.a Longitude - latitude grid
!
        IF (ITYPE.EQ.2) THEN
          WRITE (NDSO,941)
!
! ... setup coordinates
!
          SXI    = (XNI-X0I)/REAL(NXI-1)
          SYI    = (YNI-Y0I)/REAL(NYI-1)
          ICLO   = ICLOSE_NONE
          IF ( FLAGLL ) THEN
            IF ( ABS(ABS(REAL(NXI)*SXI)-360.) .LT. 0.1*ABS(SXI) ) THEN
              ICLO = ICLOSE_SMPL
            END IF
          END IF
!
! ... create grid search utility
!
          GSI = W3GSUC( .TRUE., FLAGLL, ICLO, NXI, NYI, ALO, ALA )
!
! ... construct interpolation data
!
!/T1              WRITE (NDST,9045)
          IF (GTYPE .NE. UNGTYPE) THEN
            DO IY=1,NY
              DO IX=1,NX
                INGRID = W3GRMP( GSI, XGRD(IY,IX), YGRD(IY,IX),      &
                                 IS, JS, RW )
                IF ( .NOT.INGRID ) THEN
                    WRITE(NDSO,1042) IX, IY, XGRD(IY,IX), YGRD(IY,IX)
                    CYCLE
                  END IF
                IX21(IX,IY) = IS(1)
                IX22(IX,IY) = IS(2)
                IY21(IX,IY) = JS(1)
                IY22(IX,IY) = JS(4)
                RD11(IX,IY) = RW(1)
                RD21(IX,IY) = RW(2)
                RD12(IX,IY) = RW(4)
                RD22(IX,IY) = RW(3)
!/T1                  WRITE (NDST,9046) IX, IY,                           &
!/T1                    IX21(IX,IY),IX22(IX,IY),IY21(IX,IY),IY22(IX,IY),  &
!/T1                    RD11(IX,IY),RD12(IX,IY),RD21(IX,IY),RD22(IX,IY)
                END DO
              END DO
          ELSE ! GTYPE .NE. UNGTYPE
            DO IX=1, NX
              X = XYB(IX,1)
              Y = XYB(IX,2)

              IX21(IX,1) =   1 + INT(MOD(360.+(X-X0I),360.)/SXI)
!
! Manages the simple closure of the grid
!
              IF (ICLO.EQ.ICLOSE_NONE) THEN 
                IX21(IX,1) =   MAX ( 1 , MIN(IX21(IX,1),NXI-1) )
                IX22(IX,1) =   IX21(IX,1) + 1
              ELSE
                IX21(IX,1) =   MAX ( 1 , MIN(IX21(IX,1),NXI) )
                IX22(IX,1) =   MOD(IX21(IX,1),NXI)+1
                END IF 
              IY21(IX,1) =   1 + INT((Y-Y0I)/SYI)
              IY21(IX,1) =   MAX ( 1 , MIN(IY21(IX,1),NYI-1) )
              IY22(IX,1) =   IY21(IX,1) + 1
!
              RW(1) =  MOD(360.+(X-X0I),360.)/SXI - REAL(IX21(IX,1)-1)
              RW(2) =  (Y-Y0I)/SYI - REAL(IY21(IX,1)-1)
!	
              IF (IY21(IX,1).EQ.1 .AND. RW(2).LT.ACC) THEN
                IF (RW(2).LT.-ACC) THEN
                  WRITE (NDSO,1044) Y
                ELSE IF (RW(2).LT.0.) THEN
                  RW(2) = 0.
!/T                  FLMOD  = .TRUE.
                END IF
              END IF
!
              IF (IY21(IX,1).EQ.NYI .AND. RW(2).GT.1.-ACC) THEN
                IF (RW(2).GT.1.+ACC) THEN
                  WRITE (NDSO,1044) Y
                ELSE IF (RW(2).GT.1.) THEN
                  RW(2) = 1.
!/T                       FLMOD  = .TRUE.
                END IF
              END IF
!	
              EFAC = SQRT ( MAX(0.,ABS(RW(1)-0.5)-0.5)**2 +  &
                            MAX(0.,ABS(RW(2)-0.5)-0.5)**2 )
              EFAC        = 1. / ( 1. + 0.25*EFAC**2 )
                

              RD11(IX,1) = EFAC * (1.-RW(1)) * (1.-RW(2))
              RD21(IX,1) = EFAC *    RW(1)   * (1.-RW(2))
              RD12(IX,1) = EFAC * (1.-RW(1)) *    RW(2)
              RD22(IX,1) = EFAC *    RW(1)   *    RW(2)
            END DO ! IX=1, NX
          END IF ! GTYPE .NE. UNGTYPE
!
          CALL W3GSUD( GSI )

!
! 4.b Grid(s) from file
!
        ELSE ! ITYPE.EQ.2
          WRITE (NDSO,942)
!
! ... prepare overlay map
!
          DO IY=1, NY
            DO IX=1, NX
              IF ( MAPSTA(IY,IX) .EQ. 0 ) THEN
                  MAPOVR(IX,IY) = ILAND
                ELSE
                  MAPOVR(IX,IY) = 0
              END IF
            END DO
          END DO
!
! ... loop over fields
!
          DO J=1, NFCOMP
!
            WRITE (NDSO,943) J
!
! ... file info lat-long file
!
            CALL NEXTLN ( COMSTR , NDSI , NDSE )
            READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR)             &
                  NXJ(J), NYJ(J), CLO(J)
            IF (NXJ(J).LT.2 .OR. NYJ(J).LT.2) THEN
                WRITE (NDSE,1036) NXJ(J), NYJ(J)
                CALL EXTCDE ( 10 )
              END IF
            IF ( ALLOCATED(MASK) ) DEALLOCATE (MASK)
            ALLOCATE ( MASK(NXJ(J),NYJ(J)) )
            MASK   = 1
            WRITE (NDSO,944) NXJ(J), NYJ(J), CLO(J)
!
            CALL NEXTLN ( COMSTR , NDSI , NDSE )
            READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR)             &
                  FROMLL, IDLALL, IDFMLL, FORMLL
            IF (IDLALL.LT.1 .OR. IDLALL.GT.4) IDLALL   = 1
            IF (IDFMLL.LT.1 .OR. IDFMLL.GT.3) IDFMLL   = 1
            WRITE (NDSO,945) IDLALL, IDFMLL
            IF (IDFMLL.EQ.2) WRITE (NDSO,946) FORMLL
!
            CALL NEXTLN ( COMSTR , NDSI , NDSE )
            READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) NDSLL, NAMELL
!/NCO                NDSLL  = 20 + NFCOMP
            WRITE (NDSO,947) NDSLL
            IF (FROMLL.EQ.'NAME') WRITE (NDSO,948) NAMELL
            IF (NDSLL.EQ.NDSI) THEN
                WRITE (NDSE,1038)
                CALL NEXTLN ( COMSTR , NDSI , NDSE )
            ELSE
!
! ... open lat-long file
!
              IF ( IDFMLL .EQ. 3 ) THEN
                IF (FROMLL.EQ.'NAME') THEN
                  JJ = LEN_TRIM(FNMPRE)
                  OPEN (NDSLL,FILE=FNMPRE(:JJ)//NAMELL,     &
                              FORM='UNFORMATTED',STATUS='OLD',    &
                              ERR=845,IOSTAT=IERR)
                ELSE
                  OPEN (NDSLL, FORM='UNFORMATTED',          &
                               STATUS='OLD',ERR=845,IOSTAT=IERR)
                END IF
              ELSE
                IF (FROMLL.EQ.'NAME') THEN
                  JJ = LEN_TRIM(FNMPRE)
                  OPEN (NDSLL,FILE=FNMPRE(:JJ)//NAMELL,     &
                              STATUS='OLD',ERR=845,IOSTAT=IERR)
                ELSE
                  OPEN (NDSLL,                              &
                              STATUS='OLD',ERR=845,IOSTAT=IERR)
                END IF
              END IF
!
            END IF
!
! ... read lat-lon data
!
            IF ( ASSOCIATED(ALA) ) THEN
                DEALLOCATE ( ALA, ALO )
                NULLIFY ( ALA, ALO )
            END IF
            ALLOCATE ( ALA(NXJ(J),NYJ(J)), ALO(NXJ(J),NYJ(J)) )
            CALL INA2R (ALA, NXJ(J), NYJ(J), 1, NXJ(J), 1, NYJ(J),&
                 NDSLL, NDST, NDSE, IDFMLL, FORMLL, IDLALL, 1., 0.)
            CALL INA2R (ALO, NXJ(J), NYJ(J), 1, NXJ(J), 1, NYJ(J),&
                 NDSLL, NDST, NDSE, IDFMLL, FORMLL, IDLALL, 1., 0.)
!
            IF ( NDSLL .NE. NDSI ) CLOSE (NDSLL)
!
! ... file info mask file
!
            WRITE (NDSO,949)
!
            CALL NEXTLN ( COMSTR , NDSI , NDSE )
            READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR)             &
                  FROMLL, IDLALL, IDFMLL, FORMLL
            IF (IDLALL.LT.1 .OR. IDLALL.GT.4) IDLALL   = 1
            IF (IDFMLL.LT.1 .OR. IDFMLL.GT.3) IDFMLL   = 1
            WRITE (NDSO,945) IDLALL, IDFMLL
            IF (IDFMLL.EQ.2) WRITE (NDSO,946) FORMLL
!
            CALL NEXTLN ( COMSTR , NDSI , NDSE )
            READ (NDSI,*,END=801,ERR=802,IOSTAT=IERR) NDSLL, NAMELL
!/NCO                NDSLL  = 22 + NFCOMP
            WRITE (NDSO,947) NDSLL
            IF (FROMLL.EQ.'NAME') WRITE (NDSO,948) NAMELL
            WRITE (NDSO,*) ' '
            IF (NDSLL.EQ.NDSI) THEN
                WRITE (NDSE,1038)
                CALL NEXTLN ( COMSTR , NDSI , NDSE )
            ELSE
!
! ... open mask file
!
              IF ( IDFMLL .EQ. 3 ) THEN
                IF (FROMLL.EQ.'NAME') THEN
                  JJ = LEN_TRIM(FNMPRE)
                  OPEN (NDSLL,FILE=FNMPRE(:JJ)//NAMELL,     &
                            FORM='UNFORMATTED',STATUS='OLD',    &
                            ERR=846,IOSTAT=IERR)
                ELSE
                  OPEN (NDSLL,FORM='UNFORMATTED',           &
                              STATUS='OLD',ERR=846,IOSTAT=IERR)
                END IF
              ELSE
                IF (FROMLL.EQ.'NAME') THEN
                  JJ = LEN_TRIM(FNMPRE)
                  OPEN (NDSLL,FILE=FNMPRE(:JJ)//NAMELL,     &
                              STATUS='OLD',ERR=846,IOSTAT=IERR)
                ELSE
                  OPEN (NDSLL,                              &
                              STATUS='OLD',ERR=846,IOSTAT=IERR)
                END IF
              END IF
!
            END IF
!
! ... read mask data
!
            CALL INA2I (MASK, NXJ(J), NYJ(J), 1,NXJ(J), 1,NYJ(J), &
                 NDSLL, NDST, NDSE, IDFMLL, FORMLL, IDLALL, 1, 0)
            IF ( NDSLL .NE. NDSI ) CLOSE (NDSLL)
!
!/T1a                WRITE (NDST,9050)
!/T1a                DO IY=1, NYJ(J)
!/T1a                  DO IX=1,NXJ(J)
!/T1a                    WRITE (NDST,9051) IX, IY, ALA(IX,IY),             &
!/T1a                           ALO(IX,IY), MASK(IX,IY)
!/T1a                    END DO
!/T1a                  END DO
!
! ... generate interpolation data
!
            IF ( J .EQ. 1 ) THEN
              CALL W3FLDP ( NDSO, NDST, NDSE, IERR, FLAGLL,       &
                NX, NY, NX, NY, YGRD, XGRD, MAPOVR, ILAND,        &
                NXJ(J), NYJ(J), NXJ(J), NYJ(J), CLO(J), ALA, ALO, &
                MASK, RD11, RD21, RD12, RD22, IX21, IX22, IY21,   &
                IY22 )
            ELSE
              CALL W3FLDP ( NDSO, NDST, NDSE, IERR, FLAGLL,       &
                NX, NY, NX, NY, YGRD, XGRD, MAPOVR, ILAND,        &
                NXJ(J), NYJ(J), NXJ(J), NYJ(J), CLO(J), ALA, ALO, &
                MASK, XD11, XD21, XD12, XD22, JX21, JX22, JY21,   &
                JY22 )
            END IF ! J .EQ. 1 
!
          END DO ! J=1, NFCOMP
!
! ... average two fields !
!
          IF ( NFCOMP .EQ. 2) THEN
            DO IX=1, NX
              DO IY=1, NY
                IF ( MAPOVR(IX,IY) .GE. 2) THEN
                  FACTOR = 1. / REAL(MAPOVR(IX,IY))
                  RD11(IX,IY) = FACTOR * RD11(IX,IY)
                  RD12(IX,IY) = FACTOR * RD12(IX,IY)
                  RD21(IX,IY) = FACTOR * RD21(IX,IY)
                  RD22(IX,IY) = FACTOR * RD22(IX,IY)
                  XD11(IX,IY) = FACTOR * XD11(IX,IY)
                  XD12(IX,IY) = FACTOR * XD12(IX,IY)
                  XD21(IX,IY) = FACTOR * XD21(IX,IY)
                  XD22(IX,IY) = FACTOR * XD22(IX,IY)
                END IF
              END DO
            END DO
          END IF ! NFCOMP .EQ. 2
!
        END IF ! ITYPE.EQ.2
      END IF ! ITYPE.NE.1 .AND. ITYPE.NE.5
!
! 4.c Input location and format
!
      DO J=1, NFCOMP
!
        IF ( ITYPE .GE. 5 ) THEN
            WRITE (NDSO,960)
          ELSE
            IF (ITYPE.LE.3) THEN
                WRITE (NDSO,961) NXJ(J), NYJ(J)
              ELSE
                WRITE (NDSO,962) J, NXJ(J), NYJ(J)
              END IF
          END IF ! ITYPE .GE. 5
!
      END DO
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 5   Prepare files
!
      IF ( NFCOMP .EQ. 1 ) THEN
          NXJ  (2) = NXJ  (1)
          NYJ  (2) = NYJ  (1)
          NDSF (2) = NDSF (1)
          IDLAF(2) = IDLAF(1)
          IDFMF(2) = IDFMF(1)
          FORMT(2) = FORMT(1)
          FORMF(2) = FORMF(1)
        END IF

! 5.b Open and prepare output file
!
      WRITE (NDSO,971)
      J      = LEN_TRIM(FNMPRE)
      IF ( ITYPE .LE. 4 ) THEN
          CALL W3FLDO ( 'WRITE', IDFLD, NDSDAT, NDST, NDSE,           &
               NX, NY, GTYPE, IERR, FPRE=FNMPRE(:J),                  &
               FHDR=FLHDR )
        ELSE
          CALL W3FLDO ( 'WRITE', IDFLD, NDSDAT, NDST, NDSE,           &
               RECLDT, 0, GTYPEDUM, IERR, FPRE=FNMPRE(:J) )
        END IF
!
! 5.c Initialize fields
!
      IF ( ITYPE .NE. 5 ) THEN
          FX = 0.
          FY = 0.
          FA = 0.
          MXM = MAX ( NXJ(1), NXJ(2) )
          MYM = MAX ( NYJ(1), NYJ(2) )
          IF (GTYPE.EQ.UNGTYPE) THEN 
            ALLOCATE ( XC(MXM,1), YC(MXM,1), AC(MXM,1) )
          ELSE
            ALLOCATE ( XC(MXM,MYM), YC(MXM,MYM), AC(MXM,MYM) )
          END IF
          XC = 0.
          YC = 0.
          AC = 0.
        END IF
!
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
! 6   Begin loop over input fields
!
!/O15      J      = LEN_TRIM(FNMPRE)
!/O15      OPEN (NDSTIME,FILE=FNMPRE(:J)//'times.'//IDFLD,      &
!/O15            ERR=870,IOSTAT=IERR )
!
      WRITE (NDSO,972)
      DO ITIME=1,NTI
!
! 6.a Read new time and fields
!
        IF ( FLTIME ) THEN
!
            iret=nf90_inq_varid(ncid,"time",varidtmp)
            call check_err(iret)
            iret=nf90_get_var(ncid,varidtmp,datecur,start=(/ITIME/))
            IF (index(timeunits, "seconds").NE.0)   datecur=datecur/86400.
            datecur=dateref+datecur
            call caldat(int(datecur),dcur,mcur,ycur)

            hcur=(datecur-int(datecur))*24
            mncur=(hcur-int(hcur))*60
            scur=(mncur-int(mncur))*60
            write(TIME_STR,'(I4.4,5I2.2)') int(ycur), int(mcur), int(dcur), &
                                          int(hcur), int(mncur), int(scur)
            read(TIME_STR(1:8),'(I8.8)') TIME(1)
            read(TIME_STR(9:14),'(I6.6)') TIME(2)

          END IF
!
        CALL STME21 ( TIME , IDTIME )
        WRITE (NDSO,973) IDTIME
!/O15        WRITE (NDSTIME, 979, ERR=871,IOSTAT=IERR) TIME
!/O3        WRITE (NDSO,974)
!
! ... Input
!
        IF ( ITYPE .LE. 4 ) THEN
            iret=nf90_inq_varid(ncid,FIELDSNAME(1),varidtmp)
            call check_err(iret)
            IF (GTYPE.EQ.UNGTYPE) THEN 
              iret=nf90_get_var(ncid,varidtmp,XC(:,1),start=(/1,ITIME/),count=(/MXM,1/))
            call check_err(iret)
            ELSE 
              iret=nf90_get_var(ncid,varidtmp,XC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))
              call check_err(iret)
            ENDIF
            !XC(:,:)=XC(:,MYM:1:-1)

!
!/T2            WRITE (NDST,9060) 1
!/T2            IXP0   = 1
!/T2            IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(1) )
!/T2            DO
!/T2              CALL PRTBLK ( NDST, NXJ(1), NYJ(1), MXM, XC, MASK, 0, 0.,&
!/T2                            IXP0, IXPN, 1, 1, NYJ(1), 1, 'Field 1', ' ')
!/T2              IF (IXPN.NE.NXJ(1)) THEN
!/T2                  IXP0    = IXP0 + IXPWDT
!/T2                  IXPN    = MIN ( IXPN+IXPWDT , NXJ(1) )
!/T2                ELSE
!/T2                  EXIT
!/T2                END IF
!/T2              END DO
!
            IF (NFCOMP.EQ.2 .OR. IFLD.GE.3 .OR. FLBERG) THEN

                iret=nf90_inq_varid(ncid,FIELDSNAME(2),varidtmp)
                call check_err(iret)
                IF (GTYPE.EQ.UNGTYPE) THEN 
                  iret=nf90_get_var(ncid,varidtmp,YC(:,1),start=(/1,ITIME/),count=(/MXM,1/))
                call check_err(iret)
                ELSE 
                  iret=nf90_get_var(ncid,varidtmp,YC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))
                  call check_err(iret)
                END IF
                !YC(:,:)=YC(:,MYM:1:-1)

!
!/T2                WRITE (NDST,9060) 2
!/T2                IXP0   = 1
!/T2                IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(2) )
!/T2                DO
!/T2                  CALL PRTBLK ( NDST, NXJ(2), NYJ(2), MXM, YC, MASK, 0, 0., &
!/T2                                IXP0, IXPN, 1, 1, NYJ(2), 1, 'Field 2', ' ')
!/T2                  IF (IXPN.NE.NXJ(2)) THEN
!/T2                      IXP0    = IXP0 + IXPWDT
!/T2                      IXPN    = MIN ( IXPN+IXPWDT , NXJ(2) )
!/T2                    ELSE
!/T2                      EXIT
!/T2                    END IF
!/T2                  END DO
!
                IF (FLSTAB) THEN

                    iret=nf90_inq_varid(ncid,FIELDSNAME(3),varidtmp)
                    call check_err(iret)
                    IF (GTYPE.EQ.UNGTYPE) THEN 
                      iret=nf90_get_var(ncid,varidtmp,AC(:,1),start=(/1,ITIME/),count=(/MXM,1/))
                    call check_err(iret)
                    ELSE 
                      iret=nf90_get_var(ncid,varidtmp,AC,start=(/1,1,ITIME/),count=(/MXM,MYM,1/))
                      call check_err(iret)
                    END IF
                    !AC(:,:)=AC(:,MYM:1:-1)
!
!/T2                    WRITE (NDST,9060) 3
!/T2                    IXP0   = 1
!/T2                    IXPN   = MIN ( IXP0+IXPWDT-1 , NXJ(2) )
!/T2                    DO
!/T2                      CALL PRTBLK ( NDST, NXJ(2), NYJ(2), MXM, AC, MASK, 0,&
!/T2                            0., IXP0, IXPN, 1,1, NYJ(2), 1, 'Field 3', ' ')
!/T2                      IF (IXPN.NE.NXJ(2)) THEN
!/T2                          IXP0    = IXP0 + IXPWDT
!/T2                          IXPN    = MIN ( IXPN+IXPWDT , NXJ(2) )
!/T2                        ELSE
!/T2                          EXIT
!/T2                        END IF
!/T2                      END DO
!
                  END IF
!
              END IF

          ELSE  ! ITYPE .NE. 5
!
            WRITE(NDSO,*) "ITYPE5 TO DO"
            IF (IDFMF(1).EQ.3) THEN
                READ (NDSF(1),  END=862,ERR=862,IOSTAT=IERR) NDAT
              ELSE
                READ (NDSF(1),*,END=862,ERR=862,IOSTAT=IERR) NDAT
              END IF
!/O3            WRITE (NDSO,975) NDAT
            IF ( NDAT.GT.0 ) THEN
                ALLOCATE ( DATA(RECLDT,NDAT) )
                DO IDAT=1, NDAT
                  IF (IDFMF(1).EQ.1) THEN
                      READ (NDSF(1),    *   ,END=863,ERR=863,         &
                            IOSTAT=IERR) DATA(:,IDAT)
                    ELSE IF (IDFMF(1).EQ.2) THEN
                      READ (NDSF(1),FORMT(1),END=863,ERR=863,         &
                            IOSTAT=IERR) DATA(:,IDAT)
                    ELSE
                      READ (NDSF(1),         END=863,ERR=863,         &
                            IOSTAT=IERR) DATA(:,IDAT)
                    END IF
                  END DO
              END IF
!
!/T2            WRITE (NDST,9061)
!/T2            DO IDAT=1, NDAT
!/T2              IX     = MIN(6,RECLDT)
!/T2              WRITE (NDST,9062) IDAT, DATA(1:IX,IDAT)
!/T2              IF ( IX.LT.RECLDT ) WRITE (NDST,9063) DATA(IX+1:,:)
!/T2              END DO
!
          END IF
!
! 6.b Interpolate fields
! ... No interpolation, type AI (should not use array syntax !!!)
!
        IF (ITYPE.EQ.1) THEN
!
            ! change fillvalue
            DO IY=1,NY
              DO IX=1,NX
                IF (XC(IX,IY) .EQ. fillvalue) XC(IX,IY)=0
                IF (YC(IX,IY) .EQ. fillvalue) YC(IX,IY)=0
              END DO
            END DO

            IF (( IFLD.LE.2 ).AND.( .NOT. FLBERG )) THEN
                DO IY=1, NY
                  DO IX=1, NX
                    FA(IX,IY) = XC(IX,IY)
                    END DO
                  END DO
              ELSE
                DO IY=1, NY
                  DO IX=1, NX
                    FX(IX,IY) = XC(IX,IY)
                    FY(IX,IY) = YC(IX,IY)
                    FA(IX,IY) = AC(IX,IY)
                    END DO
                  END DO
              END IF
!
          ELSE IF (ITYPE.NE.5) THEN

            ! change fillvalue
            DO IY=1,NY
              DO IX=1,NX
                IF (XC(IX21(IX,IY),IY21(IX,IY)) .EQ. fillvalue) XC(IX21(IX,IY),IY21(IX,IY))=0
                IF (XC(IX22(IX,IY),IY21(IX,IY)) .EQ. fillvalue) XC(IX22(IX,IY),IY21(IX,IY))=0
                IF (XC(IX21(IX,IY),IY22(IX,IY)) .EQ. fillvalue) XC(IX21(IX,IY),IY22(IX,IY))=0
                IF (XC(IX22(IX,IY),IY22(IX,IY)) .EQ. fillvalue) XC(IX22(IX,IY),IY22(IX,IY))=0
                IF (YC(IX21(IX,IY),IY21(IX,IY)) .EQ. fillvalue) YC(IX21(IX,IY),IY21(IX,IY))=0
                IF (YC(IX22(IX,IY),IY21(IX,IY)) .EQ. fillvalue) YC(IX22(IX,IY),IY21(IX,IY))=0
                IF (YC(IX21(IX,IY),IY22(IX,IY)) .EQ. fillvalue) YC(IX21(IX,IY),IY22(IX,IY))=0
                IF (YC(IX22(IX,IY),IY22(IX,IY)) .EQ. fillvalue) YC(IX22(IX,IY),IY22(IX,IY))=0
              END DO
            END DO
!
! ... One-component fields
!
!/O3            WRITE (NDSO,976) ' '
            IF (( IFLD.LE.2 ).AND.( .NOT. FLBERG )) THEN
!
                DO IY=1,NY
                  DO IX=1,NX
                    FA(IX,IY)                                         &
                          = RD11(IX,IY) * XC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * XC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * XC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * XC(IX22(IX,IY),IY22(IX,IY))
                    END DO
                  END DO
!
                IF (NFCOMP.EQ.2) THEN
!/O3                WRITE (NDSO,976) ' (2) '
                    DO IY=1,NY
                      DO IX=1,NX
                        FA(IX,IY) = FA(IX,IY)                         &
                          + XD11(IX,IY) * YC(JX21(IX,IY),JY21(IX,IY)) &
                          + XD21(IX,IY) * YC(JX22(IX,IY),JY21(IX,IY)) &
                          + XD12(IX,IY) * YC(JX21(IX,IY),JY22(IX,IY)) &
                          + XD22(IX,IY) * YC(JX22(IX,IY),JY22(IX,IY))
                        END DO
                      END DO
                  END IF
!
! ... Two-component fields
!
              ELSE  !so if IFLD.GT.2
!
                DO IY=1,NY
                  DO IX=1,NX
                    FX(IX,IY)                                         &
                          = RD11(IX,IY) * XC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * XC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * XC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * XC(IX22(IX,IY),IY22(IX,IY))
                    FY(IX,IY)                                         &
                          = RD11(IX,IY) * YC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * YC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * YC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * YC(IX22(IX,IY),IY22(IX,IY))
                    FA(IX,IY)                                         &
                          = RD11(IX,IY) * AC(IX21(IX,IY),IY21(IX,IY)) &
                          + RD21(IX,IY) * AC(IX22(IX,IY),IY21(IX,IY)) &
                          + RD12(IX,IY) * AC(IX21(IX,IY),IY22(IX,IY)) &
                          + RD22(IX,IY) * AC(IX22(IX,IY),IY22(IX,IY))
                    A1(IX,IY) = MAX ( 1.E-10 ,                        &
                                  SQRT( FX(IX,IY)**2 + FY(IX,IY)**2 ) )
                    A2(IX,IY)                                         &
                         = RD11(IX,IY) * SQRT(XC(IX21(IX,IY),IY21(IX,IY))**2  &
                                             +YC(IX21(IX,IY),IY21(IX,IY))**2) &
                         + RD21(IX,IY) * SQRT(XC(IX22(IX,IY),IY21(IX,IY))**2  &
                                             +YC(IX22(IX,IY),IY21(IX,IY))**2) &
                         + RD12(IX,IY) * SQRT(XC(IX21(IX,IY),IY22(IX,IY))**2  &
                                             +YC(IX21(IX,IY),IY22(IX,IY))**2) &
                         + RD22(IX,IY) * SQRT(XC(IX22(IX,IY),IY22(IX,IY))**2  &
                                             +YC(IX22(IX,IY),IY22(IX,IY))**2)
                    A3(IX,IY) = SQRT (                                &
                           RD11(IX,IY) * ( XC(IX21(IX,IY),IY21(IX,IY))**2   &
                                         + YC(IX21(IX,IY),IY21(IX,IY))**2 ) &
                         + RD21(IX,IY) * ( XC(IX22(IX,IY),IY21(IX,IY))**2   &
                                         + YC(IX22(IX,IY),IY21(IX,IY))**2 ) &
                         + RD12(IX,IY) * ( XC(IX21(IX,IY),IY22(IX,IY))**2   &
                                         + YC(IX21(IX,IY),IY22(IX,IY))**2 ) &
                         + RD22(IX,IY) * ( XC(IX22(IX,IY),IY22(IX,IY))**2   &
                                         + YC(IX22(IX,IY),IY22(IX,IY))**2 ) )
                    END DO
                  END DO
!
! ... Winds, correct for velocity or energy conservation
!
!/WNT1                IF (IFLD.EQ.3) THEN
!/WNT1                    DO IY=1,NY
!/WNT1                      DO IX=1,NX
!/WNT1                        FACTOR = MIN ( 1.5 , A2(IX,IY)/A1(IX,IY) )
!/WNT1                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/WNT1                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/WNT1                        END DO
!/WNT1                      END DO
!/WNT1                  END IF
!
!/WNT2                IF (IFLD.EQ.3) THEN
!/WNT2                    DO IY=1,NY
!/WNT2                      DO IX=1,NX
!/WNT2                        FACTOR = MIN ( 1.5 , A3(IX,IY)/A1(IX,IY) )
!/WNT2                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/WNT2                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/WNT2                        END DO
!/WNT2                      END DO
!/WNT2                  END IF
!
! ... Currents, correct for velocity or energy conservation
!
!/CRT1                IF (IFLD.EQ.4) THEN
!/CRT1                    DO IY=1,NY
!/CRT1                      DO IX=1,NX
!/CRT1                        FACTOR = MIN ( 1.5 , A2(IX,IY)/A1(IX,IY) )
!/CRT1                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/CRT1                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/CRT1                        END DO
!/CRT1                      END DO
!/CRT1                  END IF
!
!/CRT2                IF (IFLD.EQ.4) THEN
!/CRT2                    DO IY=1,NY
!/CRT2                      DO IX=1,NX
!/CRT2                        FACTOR = MIN ( 1.5 , A3(IX,IY)/A1(IX,IY) )
!/CRT2                        FX(IX,IY) = FACTOR * FX(IX,IY)
!/CRT2                        FY(IX,IY) = FACTOR * FY(IX,IY)
!/CRT2                        END DO
!/CRT2                      END DO
!/CRT2                 END IF
!
              END IF
!
          END IF
!
! ... Test output
!
!/T3        IF ( .NOT. ALLOCATED(MAPOUT) ) ALLOCATE ( MAPOUT(NX,NY) )
!/T3        WRITE (NDST,9065)
!/T3        DO IX=1, NX
!/T3          DO IY=1, NY
!/T3            MAPOUT(IX,IY) = MAPSTA(IY,IX)
!/T3            END DO
!/T3          END DO
!/T3        IX0    = 1
!/T3        IXN    = MIN ( IX0+IXWDT-1 , NX )
!/T3        DO
!/T3          IF (IFLD.EQ.1) THEN
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Fraction ice', '(-)')
!/T3              IF ( FLBERG )                                       &
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Iceberg a', '0.1/km')
!/T3            ELSE IF (IFLD.EQ.2) THEN
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Water level', 'm')
!/T3            ELSE
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FX, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Cart. X-comp', 'm/s')
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FY, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Cart. Y-comp', 'm/s')
!/T3              IF ( FLSTAB )                                       &
!/T3              CALL PRTBLK (NDSO, NX, NY, NX, FA, MAPOUT, 0, 0.,   &
!/T3                      IX0, IXN, 1, 1, NY, 1, 'Tair-Tsea', 'degr')
!/T3            END IF
!/T3          IF (IXN.NE.NX) THEN
!/T3              IX0    = IX0 + IXWDT
!/T3              IXN    = MIN ( IXN+IXWDT , NX )
!/T3            ELSE
!/T3              EXIT
!/T3            END IF
!/T3          END DO
!
! 6.c Write fields
!
        IF ( ITYPE .LE. 4 ) THEN
!/O3       WRITE (NDSO,977)
          CALL W3FLDG ('WRITE', IDFLD, NDSDAT, NDST, NDSE, NX, NY,  &
                       NX, NY, TIME, TIME, TIME, FX, FY, FA, TIME,  &
                       FX, FY, FA, IERR)

        ELSE IF ( ITYPE .EQ. 5 ) THEN
          IF ( NDAT .EQ. 0 ) THEN
!/O3         WRITE (NDSO,978)
          ELSE
!/O3         WRITE (NDSO,977)
            CALL W3FLDD ('WRITE', IDFLD, NDSDAT, NDST, NDSE, TIME,&
                         TIME, RECLDT, NDAT, IDAT, DATA, IERR )
            DEALLOCATE ( DATA )
          END IF
        END IF
        IF (IERR.NE.0) CALL EXTCDE ( 30 )
!
      END DO
!
      DEALLOCATE(XC,YC,AC)
      DEALLOCATE(ALA,ALO)
      DEALLOCATE(varndims,vardimids,varname,varid,dimname,dimid,dimln)
!
!     End loop over input fields
!--- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
      GOTO 888
!
! Error escape locations
!
  800 CONTINUE
      WRITE (NDSE,1000) IERR
      CALL EXTCDE ( 40 )
!
  801 CONTINUE
      WRITE (NDSE,1001)
      CALL EXTCDE ( 41 )
!
  802 CONTINUE
      WRITE (NDSE,1002) IERR
      CALL EXTCDE ( 42 )
!
  837 CONTINUE
      WRITE (NDSE,1037) NDSI
      CALL EXTCDE ( 43 )
!
  840 CONTINUE
      WRITE (NDSE,1040) X0I, XNI
      CALL EXTCDE ( 45 )
!
  841 CONTINUE
      WRITE (NDSE,1041) Y0I, YNI
      CALL EXTCDE ( 46 )
!
  845 CONTINUE
      WRITE (NDSE,1045) IERR
      CALL EXTCDE ( 47 )
!
  846 CONTINUE
      WRITE (NDSE,1046) IERR
      CALL EXTCDE ( 48 )
!
  850 CONTINUE
      WRITE (NDSE,1050) IERR, NDSF(J), NAMEF
      CALL EXTCDE ( 49 )
!
  860 CONTINUE
      WRITE (NDSE,1060) J, IERR
      CALL EXTCDE ( 50 )
!
  861 CONTINUE
      WRITE (NDSE,1061) TIME, TIME2
      CALL EXTCDE ( 51 )
!
  862 CONTINUE
      WRITE (NDSE,1062) IERR
      CALL EXTCDE ( 52 )
!
  863 CONTINUE
      WRITE (NDSE,1063) IDAT, IERR
      CALL EXTCDE ( 53 )
!
!/O15  870 CONTINUE
!/O15      WRITE (NDSE,1070) IDFLD, IERR
!/O15      CALL EXTCDE ( 54 )
!
!/O15  871 CONTINUE
!/O15      WRITE (NDSE,1071) IDTIME, IERR
!/O15      CALL EXTCDE ( 54 )
!
  888 CONTINUE
      WRITE (NDSO,999)
!
!/NCO/!     CALL W3TAGE('WAVEPREP')
!
! Formats
!
  900 FORMAT (/15X,'  *** WAVEWATCH III  Input pre-processing ***  '/ &
               15X,'==============================================='/)
  901 FORMAT ( '  Comment character is ''',A,''''/)
  902 FORMAT ( '  Grid name : ',A/)
!
  930 FORMAT (/'  Description of inputs'/                             &
               ' --------------------------------------------------'/ &
               '       Input type        : ',A/                       &
               '       Format type       : ',A)
 1930 FORMAT ( '          Field conserves velocity.')
 2930 FORMAT ( '          Field corrected for energy conservation.')
  931 FORMAT (/'       Single field, time: ',A)
  932 FORMAT (/'       Input grid dim.   :',I5,3X,I5)
  933 FORMAT ( '       Longitude range   :',2F8.2,' (deg)'/           &
               '       Latitude range    :',2F8.2,' (deg)')
  733 FORMAT ( '       X range           :',2F8.2,' (km)'/           &
               '       Y range           :',2F8.2,' (km)')
  934 FORMAT (/'       Data type         : ',A/                       &
               '       Data record length:',I5/                       &
               '       Missing values    :',F8.2)
  935 FORMAT ( 'DT',I1 )
  938 FORMAT ( '          Icebergs included.')
  939 FORMAT ( '          Air-sea temperature differences included.')
!
  940 FORMAT (//'  Preprocessing data'/                               &
               ' --------------------------------------------------')
  941 FORMAT ( '       Interpolation factors ..... '/                 &
               '          (longitude-latitude grid)')
  942 FORMAT ( '       Interpolation factors ..... '/                 &
               '          (grid from file)')
  943 FORMAT (/'           Longitude-latitude file ',I1,' :'/         &
               '          ---------------------------------------')
  944 FORMAT ( '           Input grid dim.   :',I5,3X,I5/             &
               '           Closed longitudes :',L5)
  945 FORMAT ( '           Layout indicator  :',I5/                   &
               '           Format indicator  :',I5)
  946 FORMAT ( '           Format            : ',A)
  947 FORMAT ( '           Unit number       :',I5)
  948 FORMAT ( '           File name         : ',A)
  949 FORMAT (/'           Corresponding map file '/                  &
               '          ---------------------------------------')
!
  960 FORMAT (/'           Data file :'/                              &
               '          ---------------------------------------')
  961 FORMAT (/'           Data file :'/                              &
               '          ---------------------------------------'/   &
               '           Input grid dim.   :',I5,3X,I5)
  962 FORMAT (/'           Data file (',I1,') :'/                     &
               '          ---------------------------------------'/   &
               '           Input grid dim.   :',I5,3X,I5)
  963 FORMAT ( '           Layout indicator  :',I5)
  964 FORMAT ( '           Format indicator  :',I5)
  965 FORMAT ( '           Format for time   : ',A/                   &
               '           Format for data   : ',A)
  966 FORMAT ( '           Unit number       :',I5)
  967 FORMAT ( '           File name         : ',A)
!
  970 FORMAT (/'       Opening input data file .....')
  971 FORMAT (/'       Opening output data file .....')
  972 FORMAT (//'  Processing data'/                                  &
               ' --------------------------------------------------')
  973 FORMAT ( '           Time : ',A)
!/O3  974 FORMAT ( '                  reading ....')
!/O3  975 FORMAT ( '                     number of data records :',I6)
!/O3  976 FORMAT ( '                  interpolating',A,'....')
!/O3  977 FORMAT ( '                  writing ....')
!/O3  978 FORMAT ( '                  skipping ....')
!
!/O15 979 FORMAT (1X,I8.8,1X,I6.6)
!
  999 FORMAT(//'  End of program '/                                   &
               ' ========================================='/          &
               '         WAVEWATCH III Input preprocessing '/)
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING INPUT FILE'/                    &
               '     IOSTAT =',I5/)
!
 1001 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     PREMATURE END OF INPUT FILE'/)
!
 1002 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING FROM INPUT FILE'/               &
               '     IOSTAT =',I5/)
!
 1030 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL FIELD ID -->',A,'<--'/)
 1031 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL FORMAT ID -->',A,'<--'/)
 1032 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     THIS FORMAT TYPE IS ALLOWED FOR ICE AND LEV ONLY'/)
!
 1033 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL DATA RECORD LENGTH : ',I6/)
 1034 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL DATA TYPE : ',I2/)
!
 1035 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL TIME : ',I8.8,I7.6/)
 1036 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL SIZE OF INPUT GRID : ',I5,1X,I5/)
 1037 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ATTEMPT TO USE INPUT UNIT (',I2,                 &
               ') FOR NAMED FILE'/)
 1038 FORMAT (/' *** WAVEWATCH III WARNING IN W3PRNC : '/             &
               '     DATA READ FROM INPUT FILE')
 1039 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ARRAYS FOR INPUT FIELDS TO SMALL '/              &
               '            GRID SIZE       :',2I5/                   &
               '            ARRAY DIMENSION :',2I5/)
!
 1040 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     LONGITUDE GRID RANGE > 360 DEGR. : ',2F6.1/)
 1041 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ILLEGAL LATITUDE GRID RANGE : ',2F6.1/)
 1042 FORMAT (/' *** WAVEWATCH-III WARNING W3PRNC : '/                &
               '     GRID POINT ',2I6,2F7.2,/                         &
               ' NOT COVERED BY INPUT GRID.'/)
 1043 FORMAT (/' *** WAVEWATCH III WARNING W3PRNC : '/                &
               '     X = ',F10.1,' NOT COVERED BY INPUT GRID.'/)
 1044 FORMAT (/' *** WAVEWATCH III WARNING W3PRNC : '/                &
               '     Y = ',F10.1,' NOT COVERED BY INPUT GRID.'/)
!

!
 1045 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING LAT-LONG DATA FILE'/            &
               '     IOSTAT =',I5/)
!
 1046 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING MASK FILE'/                     &
               '     IOSTAT =',I5/)
!
 1050 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN OPENING INPUT DATA FILE'/               &
               '     IOSTAT =',I5/                                    &
               '     NDSF   =',I5/                                    &
               '     NAMEF  = ',A/)
 1051 FORMAT (/' *** WAVEWATCH III ERROR IN W3PREP : '/               &
               '     CANNOT READ UNFORMATTED FROM UNIT',I3/)
!
 1060 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING TIME FROM FILE (',I1,')'/       &
               '     IOSTAT =',I5/)
 1061 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     INCOMPATIBLE FIELD TIMES '/                      &
               '            FIELD #1 : ',I8.8,I7.6/                   &
               '            FIELD #2 : ',I8.8,I7.6/)
 1062 FORMAT (/' *** WAVEWATCH III ERROR IN W3PREP : '/               &
               '     ERROR IN READING NDAT FROM FILE'/                &
               '     IOSTAT =',I5/)
 1063 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/               &
               '     ERROR IN READING DATA RECORD',I6,' FROM FILE'/   &
               '     IOSTAT =',I5/)
!
!/O15 1070 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/          &
!/O15               '     ERROR IN CREATING A TIMES FILE FOR ',A/     &
!/O15               '     IOSTAT =',I5/)
!/O15 1071 FORMAT (/' *** WAVEWATCH III ERROR IN W3PRNC : '/          &
!/O15               '     ERROR IN WRITING TIME OUTPUT ',A/           &
!/O15               '     IOSTAT =',I5/)
!
!/T 9000 FORMAT (' TEST W3PRNC : ACC : ',F6.3)
!
!/T 9040 FORMAT (' TEST W3PRNC : INPUT GRID RANGES AND INCR. AFTER CORR.'/ &
!/T              '               LON / X : ',3F10.2,                   &
!/T              ' (GLOBAL=',L1,')'/                                     &
!/T              '               LAT / Y : ',3F10.2)
!/T 9041 FORMAT (' TEST W3PRNC : INTERPOLATION DATA FOR ',A)
!/T 9042 FORMAT ('              ',I4,F8.2,2I4,2F8.2,1X,F6.3,1X,A)
!/T 9043 FORMAT (' TEST W3PRNC : GRID SHIFTED BY ',F5.0,' DEGREES / M')
!/T1 9045 FORMAT (' TEST W3PRNC : IX, IY, IXI(2), IYI(2), RD(4)')
!/T1 9046 FORMAT ('     ',2I4,2X,4I4,2X,4F6.2)
!
!/T1a 9050 FORMAT (' TEST W3PRNC : LAT-LONG OF INPUT FILE ')
!/T1a 9051 FORMAT ('             ',2I4,2F8.2,I4)
!
!/T2 9060 FORMAT (' TEST W3PRNC : INPUT FIELD (',I1,') :'/)
!/T2 9061 FORMAT (' TEST W3PRNC : INPUT DATA RECORDS :')
!/T2 9062 FORMAT ('      ',I6,' : ',6E11.3)
!/T2 9063 FORMAT ('               ',6E11.3)
!/T3 9065 FORMAT (' TEST W3PRNC : OUTPUT FIELD(S) :'/)
!/
!/ End of W3PRNC ----------------------------------------------------- /
!/

END PROGRAM W3PRNC

!*********************************************************************

  subroutine check_err(iret)

  USE NETCDF

  implicit none

  integer iret

  if (iret .ne. NF90_NOERR) then
     print *, nf90_strerror(iret)
     stop
  endif
  return
  END subroutine check_err


!*********************************************************************


SUBROUTINE SPLIT(STRING,TAB)

IMPLICIT NONE



   CHARACTER, intent(IN)                :: STRING*1024
   CHARACTER, intent(INOUT)             :: TAB(*)*30
   INTEGER                              :: cnt, I
   CHARACTER                            :: tmp_str*1024, ori_str*1024

   ! initializes arrays
   ori_str=ADJUSTL(TRIM(STRING))
   tmp_str=ori_str
   cnt=0

   ! counts the number of substrings
   DO WHILE ((INDEX(tmp_str,' ').NE.0) .AND. (len_trim(tmp_str).NE.0))
     tmp_str=tmp_str(INDEX(tmp_str,' ')+1:)
     cnt=cnt+1
   ENDDO

   ! reinitializes arrays
   tmp_str=ori_str

   ! loops on each substring
   DO I=1,cnt
     TAB(I)=tmp_str(:INDEX(tmp_str,' '))
     tmp_str=tmp_str(INDEX(tmp_str,' ')+1:)
   ENDDO

   return

END SUBROUTINE SPLIT
