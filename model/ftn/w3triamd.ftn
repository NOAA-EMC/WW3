MODULE W3TRIAMD
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |       F. Ardhuin and A. Roland    |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          30-Aug-2012|
!/                  +-----------------------------------+
!/
!/    15-Mar-2007 : Origination.                        ( version 3.13 )
!/    25-Aug-2011 : Modification of boundary treatment  ( version 4.04 )
!/    30-Aug-2012 : Automatic detection of open BC      ( version 4.08 )
!/    02-Sep-2012 : Clean up of open BC for UG grids    ( version 4.08 )
!/
!
!  1. Purpose :
!
!      Reads triangle and unstructured grid information
!
!  2. Method :
!
!     Look for namelist with name NAME in unit NDS and read if found.
!
!  3. Parameters :
!
!
!  4. Subroutines used :
!
!      Name               Type  Module   Description
!     ------------------------------------------------------------------------------------
!      READTRI            Subr. Internal Read unstructured grid data from .grd .tri formatted files.
!      READMSH            Subr.   Id.    Read unstructured grid data from MSH format
!      COUNT              Subr. Internal Count connection.
!      SPATIAL_GRID       Subr.   Id.    Calculate surfaces.
!      NVECTRI            Subr.   Id.    Define cell normals and angles and edge length
!      COORDMAX           Subr.   Id.    Calculate  useful grid elements
!      AREA_SI            Subr.   Id.    Define Connections
!     ------------------------------------------------------------------------------------
!
!
!  5. Called by :
!
!     Program in which it is contained.
!
!  6. Error messages :
!
!  7. Remarks :
!     The only point index which is needed is IX and NX stands for the total number of grid point.
!     IY and NY are not needed anymore, they are set to 1 in the unstructured case
!     Some noticeable arrays are:
!                     XYB    : give the 2D coordinates of all grid points
!                     TRIGP  : give the vertices of each triangle
!  8. Structure :
!
!  9. Switches :
!       !/PR3   : Enables unstructured meshes (temporary, will be replace by Unstructured switch)
!       !/LLG   : Spherical longitude-latitude grid
!       !/XYG   : Cartesian grid
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
 PUBLIC
!      USE CONSTANTS
!      USE W3GDATMD, ONLY: W3NMOD, W3SETG
!      USE W3ODATMD, ONLY: W3NO<UT, W3SETO, W3DMO5
!      USE W3IOGRMD, ONLY: W3IOGR
!     USE W3SERVMD, ONLY: ITRACE, NEXTLN, EXTCDE
!!/S      USE W3SERVMD, ONLY: STRACE
!      USE W3ARRYMD, ONLY: INA2R, INA2I
!!/T      USE W3ARRYMD, ONLY: PRTBLK
!      USE W3DISPMD, ONLY: DISTAB
!      USE W3GDATMD
!      USE W3ODATMD, ONLY: NDSE, NDST, NDSO
!      USE W3ODATMD, ONLY: NBI, NBI2, NFBPO, NBO, NBO2, FLBPI, FLBPO,  &
!                         IPBPO, ISBPO, XBPO, YBPO, RDBPO, FNMPRE
!--------------------------------------------------------------------- 
! 
!C
        integer :: node_num
        integer :: dim_num
        integer :: triangle_order
        integer :: triangle_num
        integer :: bound_edge_num
        integer :: bound_num
!C        
        logical,save, allocatable :: edge_boundary(:)
        logical,save, allocatable :: node_boundary(:)
        integer,save, allocatable :: edge_nums(:)
        integer,save, allocatable :: boundary_node_index(:)
!C        
        integer,save, allocatable :: triangle_node(:,:)
        integer,save, allocatable :: edge(:,:)
        integer,save, allocatable :: edge_index(:,:)

        INTEGER, SAVE                      :: N_OUTSIDE_BOUNDARY
        INTEGER, SAVE, ALLOCATABLE         :: OUTSIDE_BOUNDARY(:)
        real (kind = 8), save, allocatable :: node_xy(:,:)
        real (kind = 8), save, allocatable :: edge_angle(:,:)
  
CONTAINS
!/ -------------------------------------------------------------------/
      SUBROUTINE READMSH(NDS,FNAME) 
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          05-Dec-2011|
!/                  +-----------------------------------+
!/
!/    15-Feb-2008 : Origination.                        ( version 3.13 )
!/    25-Aug-2011 : Change of method for IOBPD          ( version 4.04 )
!/
!
!  1. Purpose :
!
!      Reads triangle and unstructured grid information from GMSH files
!      Calls the subroutines needed to compute grid connectivity
!
!  2. Method :
!
!     Look for namelist with name NAME in unit NDS and read if found.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NDS     Int.   I   Data set number used for search.
!       NAME    C*4    I   Name of namelist.
!       STATUS  C*20   O   Status at end of routine,
!                            '(default values)  ' if no namelist found.
!                            '(user def. values)' if namelist read.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name               Type  Module   Description
!     ------------------------------------------------------------------------------------
!      NEXTLN             Subr.
!      COUNT              Subr. Internal Count connection.
!      SPATIAL_GRID       Subr.   Id.    Calculate surfaces.
!      NVECTRI            Subr.   Id.    Define cell normals and angles and edge length
!      COORDMAX           Subr.   Id.    Calculate  useful grid elements
!      AREA_SI            Subr.   Id.    Define Connections
!     ----------------------------------------------------------------
!
!
!
!  5. Called by :
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3GRID    Prog.          Model configuration program
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     The only point index which is needed is IX and NX stands for the total number of grid point.
!     IY and NY are not needed anymore, they are set to 1 in the unstructured case
!     Some noticeable arrays are:
!                     XYB    : give the 2D coordinates of all grid points
!                     TRIGP  : give the vertices of each triangle
!     GMSH file gives too much information that is not necessarily required so data processing is needed (data sort and nesting).
!  8. Structure :
!
!  9. Switches :
!       !/PR3   : Enables unstructured meshes (temporary, will be replace by Unstructured switch)
!       !/LLG   : Spherical longitude-latitude grid
!       !/XYG   : Cartesian grid
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE W3ODATMD, ONLY: NDSE, NDST, NDSO
      USE W3GDATMD
      USE W3SERVMD, ONLY: ITRACE, NEXTLN, EXTCDE
!
      IMPLICIT NONE
!/
!/ Parameter list
!/
      INTEGER, INTENT(IN)                :: NDS
      CHARACTER(60), INTENT(IN)          :: FNAME
!/
!/ local parameters 
!/      
      INTEGER                            :: i,j,k, NODES, NELTS, ID, KID
      INTEGER                            :: ID1, ID2, KID1
      INTEGER                            :: I1, I2, I3
      INTEGER(KIND=4)                    :: Ind,eltype,ntag, INode
      CHARACTER                          :: COMSTR*1, SPACE*1 = ' ', CELS*64
      REAL, ALLOCATABLE                  :: TAGS(:)
      CHARACTER(LEN=64), ALLOCATABLE     :: ELS(:)
      CHARACTER(LEN=120)                 :: LINE
      CHARACTER(LEN=50)                  :: CHTMP
      CHARACTER(LEN=10)                  :: A, B, C
      INTEGER,ALLOCATABLE                :: NELS(:), TRIGPTMP1(:,:), TRIGPTMP2(:,:)
      INTEGER(KIND=4),ALLOCATABLE        :: IFOUND(:), VERTEX(:), BOUNDTMP(:)
      DOUBLE PRECISION, ALLOCATABLE      :: XYBTMP1(:,:),XYBTMP2(:,:)
      REAL                               :: z

      OPEN(NDS,FILE = FNAME,STATUS='old')
      READ (NDS,'(A)') COMSTR
      IF (COMSTR.EQ.' ') COMSTR = '$'
      CALL NEXTLN(COMSTR, NDS, NDSE)
      READ(NDS,*) i,j,k
      CALL NEXTLN(COMSTR, NDS, NDSE)

!
! read number of nodes and nodes from Gmsh files
!
      READ(NDS,*) NODES
      ALLOCATE(XYBTMP1(NODES,3))
      DO I= 1, NODES
        READ(NDS,*) j, XYBTMP1(I,1), XYBTMP1(I,2), XYBTMP1(I,3)
        END DO
!
! read number of elements and elements from Gmsh files
!
     ALLOCATE(BOUNDTMP(NODES))
     N_OUTSIDE_BOUNDARY = 0
     CALL NEXTLN(COMSTR, NDS, NDSE)
      READ(NDS,*) NELTS
      ALLOCATE(TRIGPTMP1(NELTS, 3))
      J = 0 
      DO I= 1, NELTS
        READ(NDS,'(A100)') LINE
        READ(LINE,*) Ind,eltype,ntag
        ALLOCATE(TAGS(ntag))
        SELECT CASE (eltype) 
!
! eltype = 15 : boundary points  (this is used to make the difference 
!                                between the outside polygon and islands)
!
        CASE(15)
          READ(LINE,*) Ind,eltype,ntag,TAGS,INODE
          N_OUTSIDE_BOUNDARY = N_OUTSIDE_BOUNDARY +1
          BOUNDTMP(N_OUTSIDE_BOUNDARY)=INODE
!
! eltype = 2 : triangles
!
        CASE (2)
          READ(LINE,*)  Ind,eltype,ntag,tags,I1, I2, I3
          J = J+ 1
          TRIGPTMP1(J,1)=I1
          TRIGPTMP1(J,2)=I2
          TRIGPTMP1(J,3)=I3
          END SELECT

        DEALLOCATE(TAGS)
        END DO
!
! organizes the grid data structure
!
      ALLOCATE(OUTSIDE_BOUNDARY(N_OUTSIDE_BOUNDARY))
      OUTSIDE_BOUNDARY(:)=BOUNDTMP(1:N_OUTSIDE_BOUNDARY)
      NTRI = J 
  
      ALLOCATE(IFOUND(NODES))
 
      IFOUND = 0
!
! Verifies that the nodes are used in at least one triangle
! 
      DO K = 1, NTRI
        I1 = TRIGPTMP1(K,1)
        I2 = TRIGPTMP1(K,2)
        I3 = TRIGPTMP1(K,3)
    
        IFOUND(I1)= IFOUND(I1) + 1
        IFOUND(I2)= IFOUND(I2) + 1
        IFOUND(I3)= IFOUND(I3) + 1
        END DO
 
      J = 0
 
      ALLOCATE(TRIGPTMP2(NTRI,3),VERTEX(NODES),XYBTMP2(NODES,3)) 
      VERTEX(:)=0
      XYBTMP2 = 0

      DO I = 1, NODES
        IF( IFOUND(I) .GT. 0) THEN
          J = J+1
          XYBTMP2(J,:) = XYBTMP1(I,:) 
          VERTEX(I) = J
          END IF
        END DO
!
! Number of nodes after clean up 
! 
      NX = J  
!
      DO I = 1, NTRI
        I1 = TRIGPTMP1(I,1)
        I2 = TRIGPTMP1(I,2)
        I3 = TRIGPTMP1(I,3)
        TRIGPTMP2(I,1)= VERTEX(I1)
        TRIGPTMP2(I,2)= VERTEX(I2)
        TRIGPTMP2(I,3)= VERTEX(I3)
        END DO   
!
      DEALLOCATE( XYBTMP1, IFOUND,TRIGPTMP1)
      DEALLOCATE(VERTEX)
!
!count points connections to allocate array in W3DIMUG 
!
      CALL COUNT(TRIGPTMP2)
      CALL W3DIMUG ( 1, NTRI, NX, COUNTOT, NNZ, NDSE, NDST ) 
!
! fills arrays
!
      DO I = 1, NX
        XYB(I,1) = XYBTMP2(I,1) 
        XYB(I,2) = XYBTMP2(I,2) 
        XYB(I,3)= XYBTMP2(I,3)
        END DO
! XGRD AND YGRD ... these are allocated by W3DIMX  
      DO I=1, NTRI
        TRIGP(I,:) = TRIGPTMP2(I,:)
        END DO   
!   
     DEALLOCATE(TRIGPTMP2,XYBTMP2)   
!
! call the various routines which define the point spotting strategy
!
     CALL SPATIAL_GRID    
     CALL NVECTRI
     CALL COORDMAX
!AR: Check for Multigrid
     CALL AREA_SI(1)
!     WRITE (NDSO,969) NX, NY, SX,DXYMAX,     &
!                      X0, MAXX,                  &
!                      Y0, MAXY
!
! Formats
!
!
!/LLG  969 FORMAT (/'  The spatial unstructured cartesian grid : '/                    &
!/LLG               ' -----------------------------------------------------'/ &
!/LLG               '       Discrete dimensions          :',I10,I3/     &
!/LLG               '       Increments min & max   (deg) :',2E14.6/     &
!/LLG               '       longitudes min &  max  (deg) :',2F12.4/     &
!/LLG               '       latitudes  min &  max  (deg) :',2F12.4)

!/XYG  969 FORMAT (/'  The spatial unstructured cartesian grid : '/                    &
!/XYG               ' -----------------------------------------------------'/ &
!/XYG               '       Discrete dimensions         :',I7,I10/     &
!/XYG               '       Increments min & max   (km) :',2E14.6/     &
!/XYG               '       X min & X max          (km) :',2F12.4/     &
!/XYG               '       Y min & Y max          (km) :',2F12.4)
      CLOSE(NDS)
      END SUBROUTINE READMSH
!/--------------------------------------------------------------------/
!/ ------------------------------------------------------------------- / 
      SUBROUTINE UG_GETOPENBOUNDARY(TMPSTA,ZBIN,ZLIM)
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          30-Aug-2012|
!/                  +-----------------------------------+
!/
!/    30-Aug-2012 : Adpatation from SHOM-Ifremer program( version 4.07 )
!/      
!
!  1. purpose: defines open boundary points based on depth
!  2. Method : a boundary node has more node around it than triangles
!      
!    
!
!  3. Parameters :
!     TMPSTA: status map to be updated (for OBC, TMPSTA = 2)
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      w3GRID    Prog.          Model configuration program
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     

!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :     
      USE W3GDATMD, ONLY: NX, NY, CCON , COUNTCON

!/S      USE W3SERVMD, ONLY: STRACE
      
      IMPLICIT NONE
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      INTEGER, INTENT(INOUT)  :: TMPSTA(NY,NX)
      REAL   , INTENT(IN)     :: ZBIN(NY,NX)
      REAL   , INTENT(IN)     :: ZLIM
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: IBC,IX

!/S      CALL STRACE (IENT, 'SETUGIOBP')      
        DO IBC = 1, N_OUTSIDE_BOUNDARY
           IX = OUTSIDE_BOUNDARY(IBC)
           IF ((TMPSTA(1,IX).EQ.1).AND.(CCON(IX) .LT. COUNTCON(IX))  &
               .AND.(ZBIN(1,IX).LT.ZLIM))  THEN 
            TMPSTA(1,IX)=2
            END IF    
          END DO     
!
    END SUBROUTINE UG_GETOPENBOUNDARY
!/ ------------------------------------------------------------------- /    


!/----------------------------------------------------------------------
      SUBROUTINE SPATIAL_GRID
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |      A. Roland  and F. Ardhuin    |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          31-Aug-2011|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/    31-Aug-2011 : Simplfies the cross products                    ( version 4.05 )
!/
!
!  1. Purpose :
!
!      Calculates triangle areas and reorders the triangles to have them 
!      oriented counterclockwise 
!
!  2. Method :
!
!     The triangle surface calculation is based on cross product.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!     This part of code is adapted from the WWM wave model develop at the Darmstadt University
!     (Aaron Roland)
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /   
         USE W3GDATMD  
         IMPLICIT NONE
!	 
!local parameters	 
! 
         REAL              :: TL1, TL2, TL3, TMPTRIGP
         INTEGER           :: I1, I2, I3
         INTEGER           :: K
!/S        INTEGER                      ::  IENT = 0          
!/ ------------------------------------------------------------------- /   
!/S      CALL STRACE (IENT, 'SPATIAL_GRID')   

                DO K = 1, NTRI
               
                   I1 = TRIGP(K,1)
                   I2 = TRIGP(K,2)
                   I3 = TRIGP(K,3)
!
! cross product of edge-vector  (orientated anticlockwise)
!                                   
                   TRIA(K) = REAL( (XYB(I2,2)-XYB(I1,2))      &     !  (Y2-Y1)
                                  *(XYB(I1,1)-XYB(I3,1))      &     ! *(X1-X3)
                                  +(XYB(I3,2)-XYB(I1,2))      &     !  (Y3-Y1)*(X2-X1)
                                  *(XYB(I2,1)-XYB(I1,1))      )*0.5
!
! test on negative triangle area, which means that the orientiation is not as assumed to be anticw. 
! therefore we swap the nodes !!! 
!      
                  IF (TRIA(K) < 0.0) THEN
         TMPTRIGP = TRIGP(K,2)
         TRIGP(K,2) = TRIGP(K,3)
         TRIGP(K,3) = TMPTRIGP
         I2 = TRIGP(K,2)
         I3 = TRIGP(K,3)
         TRIA(K) = -1.0*TRIA(K)
         END IF    
       TRIA03(K)=TRIA(K)*1./3. 
       END DO
     END SUBROUTINE
!/--------------------------------------------------------------------/
!
!/--------------------------------------------------------------------/
     SUBROUTINE DIFFERENCE
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland               |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2007|
!/                  +-----------------------------------+
!/
!/    15-Nov-2007 : Origination.                        ( version 3.13 )
!/
!
!  1. Purpose :
!
!      Calculate interpolation coefficient used gradient computation.
!
!  2. Method :
!
!     The interpolation coefficient are inspired by cross product.
!     The estimation uses Gauss' formula: the area integral of the gradient
!       is equal to the flux through the boundary. This formula is applied 
!       on individual triangles. 
!     The gradient at each grid node is then the angle-weighted sum of the 
!       gradients in each triangle. 
!       
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!     This part of code is adapted from the WWM wave model develop at the Darmstadt University
!     (Aaron Roland)
!     The gradients to be calculated are for depth and currents.
!     The three arrays  DW, CX and CY are allocated from 0 to NSEA and assuming that 
!     DW(0)=0.,CX(0)=0.,CY(0)=0. (MAPFS(1,IX) = 0 for the contour and land points) to abide by the 
!     structure of the array which are used through the code. So gradients could be irregular near 
!     the border. The interpolation coefficient reckoned in this subroutine consider this artificial 
!     discontinuity of value (between point on the border and point close to the border) and then
!     restore true gradients. 
!
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
       USE W3GDATMD 

       IMPLICIT NONE

!
!local parameter 
!
         INTEGER           :: I1, I2, I3
         REAL              :: X1(3), X2(3), X3(3)
         INTEGER           :: K
         REAL              :: FACT
!/S        INTEGER                      ::  IENT = 0 
!/ ------------------------------------------------------------------- /       

!/S      CALL STRACE (IENT, 'DIFFERENCE')

   DO K = 1, NTRI 
     I1 = TRIGP(K,1)
     I2 = TRIGP(K,2)
     I3 = TRIGP(K,3)
!
! counters which stands for occurence of a vertex in the whole triangle list, i.e the number of its
! connected triangle
!		   
     X1(:) = XYB(I1,:)
     X2(:) = XYB(I2,:)
     X3(:) = XYB(I3,:)
!
! test to see if vertices are on the contour. if it is so, its coordinates are nullyfied
! this is perform to get better gradients at grid points near the contour.
!		  
     IF ((MAPSTA(1,I1).EQ.0).OR.(MAPSTA(1,I2).EQ.0)) THEN
       X1(:) = 0. 
       X2(:) = 0.
       END IF    
      IF ((MAPSTA(1,I1).EQ.0).OR.(MAPSTA(1,I3).EQ.0)) THEN
        X1(:) = 0. 
        X3(:) = 0.
        END IF
      IF ((MAPSTA(1,I3).EQ.0).OR.(MAPSTA(1,I2).EQ.0)) THEN
        X2(:) = 0. 
        X3(:) = 0.
        END IF

      FACT = 1./(2*TRIA(K))
!
! interpolation coefficient: these are the components of the normals to the 
! triangle sides, multiplied by the side length and divided by 2 times the 
! triangle area
!		   		   
      CROSSDIFF(1,K) = REAL(X2(2) - X3(2)) * FACT
      CROSSDIFF(2,K) = REAL(X3(2) - X1(2)) * FACT
      CROSSDIFF(3,K) = REAL(X1(2) - X2(2)) * FACT
      CROSSDIFF(4,K) = REAL(X3(1) - X2(1)) * FACT
      CROSSDIFF(5,K) = REAL(X1(1) - X3(1)) * FACT
      CROSSDIFF(6,K) = REAL(X2(1) - X1(1)) * FACT

      END DO
END SUBROUTINE

!/--------------------------------------------------------------------

    SUBROUTINE NVECTRI
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/
!
!  1. Purpose :
!
!      Calculate cell tools: inward normal, angles and length of edges.
!
!  2. Method :
!      To get inward pointing normals, triangle are glanced through anti-clockwisely
!     
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
    USE W3GDATMD
    USE CONSTANTS

         IMPLICIT NONE
	 
!
!local parameter 
!	 
	 
         INTEGER :: IP, IE
         INTEGER :: I1, I2, I3, I11, I22, I33
         REAL    :: P1(2), P2(2), P3(2)
         REAL    :: R1(2), R2(2), R3(2)
         REAL    :: N1(2), N2(2), N3(2)
	 REAL    :: TMP(3)
	 REAL    :: TMPINV(3)
!/S        INTEGER                      ::  IENT = 0 	 
!/ ------------------------------------------------------------------- /   
!/S      CALL STRACE (IENT, 'NVECTRI')   

    
         DO IE = 1, NTRI
!
! vertices
!
            I1 = TRIGP(IE,1)
            I2 = TRIGP(IE,2)
            I3 = TRIGP(IE,3)
                           
            P1(1) = XYB(I1,1)
            P1(2) = XYB(I1,2)
            P2(1) = XYB(I2,1)
            P2(2) = XYB(I2,2)
            P3(1) = XYB(I3,1)
            P3(2) = XYB(I3,2)
!
! I1 -> I2, I2 -> I3, I3 -> I1 (anticlockwise orientation is preserved)
!                    
            R1 = P3-P2
            R2 = P1-P3
            R3 = P2-P1
        
            N1(1) = (-R1(2))
            N1(2) = ( R1(1))
            N2(1) = (-R2(2))
            N2(2) = ( R2(1))
            N3(1) = (-R3(2))
            N3(2) = ( R3(1))  
!
! edges length
!            
            LEN(IE,1) = SQRT(R1(1)**2.+R1(2)**2.)
            LEN(IE,2) = SQRT(R2(1)**2.+R2(2)**2.)
            LEN(IE,3) = SQRT(R3(1)**2.+R3(2)**2.)   
!
! inward normal used for propagation (not normalized)
!            
            IEN(IE,1) = N1(1)
            IEN(IE,2) = N1(2)
            IEN(IE,3) = N2(1)
            IEN(IE,4) = N2(2)
            IEN(IE,5) = N3(1)
            IEN(IE,6) = N3(2)
    
            TMP(1)  = DOT_PRODUCT(R3,-R2)
            TMP(2)  = DOT_PRODUCT(R1,-R3)
            TMP(3)  = DOT_PRODUCT(R2,-R1)

            TMPINV(1) = 1./ (LEN(IE,2) * LEN(IE,3))
            TMPINV(2) = 1./ (LEN(IE,1) * LEN(IE,3))
            TMPINV(3) = 1./ (LEN(IE,2) * LEN(IE,1))

            TMP(1)  = DOT_PRODUCT(R3,-R2) * TMPINV(1)
            TMP(2)  = DOT_PRODUCT(R1,-R3) * TMPINV(2)
            TMP(3)  = DOT_PRODUCT(R2,-R1) * TMPINV(3)
!
!  angles used in gradients computation 
!     
            ANGLE0(IE,1) = ACOS(TMP(1))
            ANGLE0(IE,2) = ACOS(TMP(2))
            ANGLE0(IE,3) = ACOS(TMP(3))
            !WRITE(997,*) 'IE, ANGLE:',IE,ANGLE0(IE,1:3)*RADE
            !TRIA03(IE)=TRIA(IE)*1./3.
         END DO
 
     END SUBROUTINE
!/---------------------------------------------------------------------------

!/------------------------------------------------------------------------

      SUBROUTINE COUNT(TRIGPTEMP)      
     
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination.                        ( version 3.13 )
!/
!      
!  1. Purpose :
!
!      Calculate global and maximum number of connection for array allocations .
!
!  2. Method :
!     
!  3. Parameters :
!     Parameter list
!     ----------------------------------------------------------------
!       NTRI         Int.   I   Total number of triangle.
!       TRIGPTEMP    Int    I   Temporary array of triangle vertices
!       COUNTRI      Int    O   Maximum number of connected triangle 
!                               for a given points
!       COUNTOT      Int    O   Global number of triangle connection 
!                               for the whole grid.   	
!     ----------------------------------------------------------------
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /  
        USE W3GDATMD

        IMPLICIT NONE

     
!/ parameter list

   INTEGER,INTENT(IN) :: TRIGPTEMP(:,:)
!/ ------------------------------------------------------------------- /   
!/ local parameter

   INTEGER               :: CONN(NX)
   INTEGER               :: COUNTER, IP, IE, I, J, N(3)
!/S        INTEGER                      ::  IENT = 0    
!/------------------------------------------------------------------------

!/S      CALL STRACE (IENT, 'COUNT')

COUNTRI=0
COUNTOT=0
CONN(:)= 0

!
!calculate the number of connected triangles for a given point.
!

DO IE = 1,NTRI
   N(:) = 0.
   N(1) = TRIGPTEMP(IE,1)
   N(2) = TRIGPTEMP(IE,2)
   N(3) = TRIGPTEMP(IE,3)
   CONN(N(1)) = CONN(N(1)) + 1
   CONN(N(2)) = CONN(N(2)) + 1
   CONN(N(3)) = CONN(N(3)) + 1
ENDDO
 
 COUNTRI = MAXVAL(CONN)
! 
! calculate the global number of connections available through the mesh
!
J=0
 DO  IP=1,NX
   DO I=1,CONN(IP)
      J=J+1
   ENDDO
 ENDDO
 COUNTOT=J  

END SUBROUTINE

!/----------------------------------------------------------------------------  
      SUBROUTINE COORDMAX
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination.                        ( version 3.13 )
!/
!  1. Purpose :
!
!      Calculate first point and last point coordinates, and minimum and maximum edge length.
!
!  2. Method :
!     
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- / 
          USE W3GDATMD
          IMPLICIT NONE
!/S        INTEGER                      ::  IENT = 0  
            
  
!/S      CALL STRACE (IENT, 'COORDMAX') 
!     
! maximum of coordinates s
!
    MAXX = MAXVAL(XYB(:,1))
    MAXY = MAXVAL(XYB(:,2))
! 
! minimum of coordinates 
!
    X0 = MINVAL(XYB(:,1))
    Y0 = MINVAL(XYB(:,2))
! 
!maximum and minimum length of edges
!
    DXYMAX = MAXVAL(LEN(:,:))
    SX = MINVAL(LEN(:,:))
    SY = SX
! 
 END SUBROUTINE
!-------------------------------------------------------------------------

  SUBROUTINE AREA_SI(IMOD)
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland               |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          23-Aug-2011|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/    23-Aug-2011 : Removes double entries in VNEIGH                ( version 4.04 )
!/  
!
!  1. Purpose :
!
!      Define optimized connection arrays (points and triangles) for spatial propagation schemes.
!
!  2. Method :
!     
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!      
!     The storage is optimize especially considering the iterative solver used.
!     The schemes used are vertex-centered, a point has to be considered within its
!     median dual cell. For a given point, the surface of the dual cell is one third
!     of the sum of the surface of connected triangles. 
!     This routine is from WWM developped in Darmstadt(Aaron Roland) 
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /      

        USE W3GDATMD

         IMPLICIT NONE
!/ input 

         INTEGER, INTENT(IN) :: IMOD 

!/ local parameters   

         INTEGER :: COUNTER,ifound,alreadyfound
         INTEGER :: I, J, K
         INTEGER :: IP, IE, POS, POS_I, POS_J, POS_K, IP_I, IP_J, IP_K
         INTEGER :: I1, I2, I3, IP2
         INTEGER :: TMP(NX), CELLVERTEX(NX,COUNTRI,2)
         INTEGER :: COUNT_MAX
         INTEGER, ALLOCATABLE :: PTABLE(:,:)
!/S        INTEGER                      ::  IENT = 0  	
!/ ------------------------------------------------------------------- /      

!/S      CALL STRACE (IENT, 'AREA_SI')
         
         SI(:) = 0.
!
! calculate the number of triangle connected to a point and reckon the surface of a dual cell
! Ask Aron: Should be uptated with water levels ???         
!
         DO IP = 1, NX
           COUNTER = 0
           DO IE = 1, NTRI  
             IF (IP == TRIGP(IE,1) .OR. IP == TRIGP(IE,2) .OR. IP== TRIGP(IE,3)) THEN
               COUNTER = COUNTER + 1
               CCON(IP) = COUNTER
               SI(IP) = SI(IP) +  1./3. * TRIA(IE) 
               END IF
             END DO
           END DO 
              
         CELLVERTEX(:,:,:) = 0
         VNEIGH(:,:) = 0
!
          DO IP = 1, NX
            COUNTER = 0
            ifound = 0
 !
 ! first step of the storage, for a given vertex, the triangle it belongs to and the vertex position
 ! are stored  
 !
            DO IE = 1, NTRI
              IF (IP == TRIGP(IE,1)) THEN
                COUNTER = COUNTER + 1
                CELLVERTEX(IP,COUNTER,1) = IE
                CELLVERTEX(IP,COUNTER,2) = 1
                DO IP2=2,3
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,IP2)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,IP2)
                    END IF
                  END DO
               END IF
              
             IF (IP == TRIGP(IE,2)) THEN
               COUNTER = COUNTER + 1
               CELLVERTEX(IP,COUNTER,1) = IE
               CELLVERTEX(IP,COUNTER,2) = 2
                DO IP2=3,4
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,MOD(IP2-1,3)+1)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,MOD(IP2-1,3)+1)
                    END IF
                  END DO
                END IF
              
             IF (IP == TRIGP(IE,3)) THEN
               COUNTER = COUNTER + 1
               CELLVERTEX(IP,COUNTER,1) = IE
               CELLVERTEX(IP,COUNTER,2) = 3
                DO IP2=1,2
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,IP2)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,IP2)
                    END IF
                  END DO
                END IF
             END DO
!
! COUNTCON is a counter on connected points. In comparison with the number of connected triangle
! CCON, it will enable to spot whether a point belong to the contour
!         
           COUNTCON(IP)=ifound
          
           do I=2,ifound
              do J=1,i-1
              if (VNEIGH(IP,J).EQ. VNEIGH(IP,I)) THEN 
                 COUNTCON(IP)=COUNTCON(IP)-1
                 ! WRITE(993,*) 'ERROR:',IP,I,J,VNEIGH(IP,J),VNEIGH(IP,I)
                 END IF
              enddo
           enddo
          
         END DO
          
         J = 0
!
! Second step in storage, the initial 3D array CELLVERTEX, is transformed in a 1D array
! the global index is J . From now, all the computation step based on these arrays must
! abide by the conservation of the 2 loop algorithm (points + connected triangles)
! AR: I will change this now to pointers in order to omit fix loop structure for the LTS stuff ...
!	   
         INDEX_CELL(1)=1
         DO IP = 1, NX
           DO I = 1, CCON(IP)
             J = J + 1
             IE_CELL(J)  = CELLVERTEX(IP,I,1)
             POS_CELL(J) = CELLVERTEX(IP,I,2) 
           END DO
           INDEX_CELL(IP+1)=J+1
         END DO

         J = 0
         DO IP = 1, NX 
           DO I = 1, CCON(IP)
             J = J + 1
           END DO
         END DO

         COUNT_MAX = J

           ALLOCATE(PTABLE(COUNT_MAX,7))

           J = 0
           PTABLE(:,:) = 0.
           DO IP = 1, NX 
             DO I = 1, CCON(IP)
               J = J + 1
               IE    = IE_CELL(J)
               POS   = POS_CELL(J)
               I1 = TRIGP(IE,1)
               I2 = TRIGP(IE,2)
               I3 = TRIGP(IE,3)
               IF (POS == 1) THEN
                 POS_J = 2
                 POS_K = 3
               ELSE IF (POS == 2) THEN
                 POS_J = 3
                 POS_K = 1
               ELSE
                 POS_J = 1
                 POS_K = 2
               END IF
               IP_I = IP
               IP_J = TRIGP(IE,POS_J)
               IP_K = TRIGP(IE,POS_K)
               PTABLE(J,1) = IP_I
               PTABLE(J,2) = IP_J
               PTABLE(J,3) = IP_K
               PTABLE(J,4) = POS
               PTABLE(J,5) = POS_J
               PTABLE(J,6) = POS_K
               PTABLE(J,7) = IE
             END DO
           END DO

!           WRITE(*,'("+TRACE......",A)') 'SET UP SPARSE MATRIX POINTER ... COUNT NONZERO ENTRY'

           J = 0
           K = 0
           DO IP = 1, NX 
             TMP(:) = 0
             DO I = 1, CCON(IP)
               J = J + 1
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               POS   = PTABLE(J,4)
               TMP(IP)   = 1
               TMP(IP_J) = 1
               TMP(IP_K) = 1
            END DO
            K = K + SUM(TMP)
          END DO

          NNZ => GRIDS(IMOD)%NNZ

          NNZ = K

!          WRITE(*,'("+TRACE......",A)') 'SET UP SPARSE MATRIX POINTER ... SETUP POINTER'

          ALLOCATE (GRIDS(IMOD)%JAA(NNZ))
          ALLOCATE (GRIDS(IMOD)%IAA(NX+1))
          ALLOCATE (GRIDS(IMOD)%POSI(3,COUNT_MAX))
          JAA   => GRIDS(IMOD)%JAA
          IAA   => GRIDS(IMOD)%IAA
          POSI  => GRIDS(IMOD)%POSI

           J = 0
           K = 0
           IAA(1) = 1
           JAA    = 0
           DO IP = 1, NX ! Run through all rows 
             TMP(:)=0
             DO I = 1, CCON(IP)         ! Check how many entries there are ...
               J = J + 1                ! this is the same J index as in IE_CELL
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               TMP(IP)   = 1
               TMP(IP_J) = 1
               TMP(IP_K) = 1
             END DO
             DO I = 1, NX               ! Run through all columns 
               IF (TMP(I) .GT. 0) THEN  ! this is true only for the connected points
                 K = K + 1              
                 JAA(K) = I
               END IF
             END DO
             IAA(IP + 1) = K + 1    
           END DO

           POSI = 0
           J = 0
           DO IP = 1, NX  
             DO I = 1, CCON(IP)
               J = J + 1
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               DO K = IAA(IP), IAA(IP+1) - 1
                 IF (IP   == JAA(K)) POSI(1,J)  = K
                 IF (IP_J == JAA(K)) POSI(2,J)  = K
                 IF (IP_K == JAA(K)) POSI(3,J)  = K
                 IF (K == 0) THEN
                  WRITE(*,*) 'ERROR IN AREA_SI K .EQ. 0'
                  STOP
                 END IF
               END DO
            END DO
          END DO

          DEALLOCATE(PTABLE)

       END SUBROUTINE   
       
!/ ------------------------------------------------------------------- /  

     SUBROUTINE TRIA_INTERPOLATION(IPT, XPT, YPT, itout, IVER, JVER, RD)

!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          01-Sep-2012|
!/                  +-----------------------------------+
!/
!/    15-Oct-2007 : Origination.                        ( version 3.13 )
!/    21-Sep-2012 : Uses same interpolation as regular  ( version 4.08 )
!/
!  1. Purpose :
!
!      Calculate interpolation coefficient for fields on the unstructured grid.
!
!  2. Method :
!      
!     Using barycentric coordinates. Each coefficient depends on the mass of its related point in the interpolation.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3IOPP    Subr. Internal  Preprocessing of point output.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!      This subroutine is adjusted from CREST code (Fabrice Ardhuin)
!      For a given output point, the algorithm enable to glance through all the triangles 
!      to find the one the point belong to, and then make interpolation.
!
!  8. Structure :
!
!  9. Switches :
!
!       !/LLG   Spherical grid.
!       !/XYG   Carthesian grid.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
 
           USE W3GDATMD, ONLY : TRIGP, NTRI, XYB, MAPSTA
           USE W3SERVMD, ONLY: EXTCDE
!/S          USE W3SERVMD, ONLY: STRACE
          USE W3ODATMD, ONLY: NDSE       
      IMPLICIT NONE
 
!/ ------------------------------------------------------------------- /       
 ! Parameter list
 
           INTEGER, INTENT(IN)            :: IPT
           REAL   , INTENT(IN)            :: XPT(:), YPT(:)
           INTEGER, INTENT(OUT)           :: itout
     INTEGER, INTENT(OUT)           :: IVER(4), JVER(4)
     REAL, INTENT(OUT)              :: RD(4)
 !/ ------------------------------------------------------------------- /                 
 !local parameters
 
           DOUBLE PRECISION             :: x1, x2, x3, x
           DOUBLE PRECISION             :: y1, y2, y3, y
           DOUBLE PRECISION             :: dM1, dM2, dM3
           DOUBLE PRECISION             :: sg1, sg2, sg3
           DOUBLE PRECISION             :: s1, s2, s3
           INTEGER                      :: ITRI, I, J, K
!/S        INTEGER                      ::  IENT = 0
!/S      CALL STRACE (IENT, 'INTERPOLATION')

!
         itout = 0 
!
! coordinates of the output point 	    
!
            x=DBLE(XPT(IPT)) 
            y=DBLE(YPT(IPT))
            DO ITRI= 1, NTRI
! coordinates of the first vertex A	    
              x1=XYB(TRIGP(ITRI,1),1) 
              y1=XYB(TRIGP(ITRI,1),2)
! coordinates of the 2nd vertex B 
              x2=XYB(TRIGP(ITRI,2),1)          
              y2=XYB(TRIGP(ITRI,2),2)
!coordinates of the 3rd vertex C	    
              x3=XYB(TRIGP(ITRI,3),1)          
              y3=XYB(TRIGP(ITRI,3),2)
!evaluate squared length between the vertices and the output point	    
              dM1=(y-y1)**2+(x-x1)**2
              dM2=(y-y2)**2+(x-x2)**2
              dM3=(y-y3)**2+(x-x3)**2
!	    
              IF (dM2 > dM3) THEN 
!vector product of BC and BA	    
                sg1=(y1-y2)*(x3-x2)-(x1-x2)*(y3-y2)    
!vector product of BC and BM     
                s1= (y -y2)*(x3-x2)-(x -x2)*(y3-y2)       
              ELSE
!vector product of CB and CA        
                sg1=(y1-y3)*(x2-x3)-(x1-x3)*(y2-y3)    
!vector product of CB and CM     
                s1= (y -y3)*(x2-x3)-(x -x3)*(y2-y3)       
                END IF
              IF (dM3 > dM1) THEN 
!vector product of CA and CB	    
                sg2=(y2-y3)*(x1-x3)-(x2-x3)*(y1-y3)    
!vector product of CA and CM	       
                s2= (y -y3)*(x1-x3)-(x -x3)*(y1-y3)       
              ELSE
!vector product of AC and AB	    
                sg2=(y2-y1)*(x3-x1)-(x2-x1)*(y3-y1)    
!vector product of AC and AM	       
                s2= (y-y1) *(x3-x1)-(x-x1) *(y3-y1)       
                END IF
              IF (dM1 > dM2) THEN 
!vector product of AB and AC
                sg3=(y3-y1)*(x2-x1)-(x3-x1)*(y2-y1)
!vector product of AB and AM   
                s3= (y-y1) *(x2-x1)-(x-x1) *(y2-y1)       
              ELSE
!vector product of BA and BC	    
                sg3=(y3-y2)*(x1-x2)-(x3-x2)*(y1-y2)  
!vector product of BA and BM	         
                s3= (y-y2) *(x1-x2)-(x-x2) *(y1-y2)       
                END IF
! test if the point is within the triangle	    
            IF ((s1*sg1.GE.0).AND.(s2*sg2.GE.0).AND.(s3*sg3.GE.0)) THEN 
              itout=ITRI
              IVER(1)=TRIGP(ITRI,1)
              IVER(2)=TRIGP(ITRI,2)
              IVER(3)=TRIGP(ITRI,3)
              IVER(4)=TRIGP(ITRI,1)
              JVER(:)=1
              RD(1)=s1/sg1    ! this is the ratio of triangles areas MBC / ABC
              RD(2)=s2/sg2    ! this is the ratio of triangles areas MAC / ABC
              RD(3)=1.-RD(1)-RD(2) 
              RD(4)=0
!PRINT*,'TRI TEST:',ITOUT 
!PRINT*, TRIGP(ITOUT,1:3)
!PRINT*, IVER
!PRINT*, RD
!PRINT*, x1,x2,x3,x
!PRINT*, y1,y2,y3,y
!PRINT*, sg1,s1,sg2,s2,sg3,s3
             END IF
           END DO
! *
      RETURN

END SUBROUTINE
!/ ------------------------------------------------------------------- /  



!/ ------------------------------------------------------------------- /  

     SUBROUTINE IS_IN_UNGRID_INTERP(IPT, XPT, YPT, itout, IVER, JVER, RD)

!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          01-Sep-2012|
!/                  +-----------------------------------+
!/
!/    15-Oct-2007 : Origination.                        ( version 3.13 )
!/    21-Sep-2012 : Uses same interpolation as regular  ( version 4.08 )
!/
!  1. Purpose :
!
!      Calculate interpolation coefficient for fields on the unstructured grid.
!
!  2. Method :
!      
!     Using barycentric coordinates. Each coefficient depends on the mass of its related point in the interpolation.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3IOPP    Subr. Internal  Preprocessing of point output.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!      This subroutine is adjusted from CREST code (Fabrice Ardhuin)
!      For a given output point, the algorithm enable to glance through all the triangles 
!      to find the one the point belong to, and then make interpolation.
!
!  8. Structure :
!
!  9. Switches :
!
!       !/LLG   Spherical grid.
!       !/XYG   Carthesian grid.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
 
           USE W3GDATMD, ONLY : TRIGP, NTRI, XYB, MAPSTA
           USE W3SERVMD, ONLY: EXTCDE
!/S          USE W3SERVMD, ONLY: STRACE
          USE W3ODATMD, ONLY: NDSE       
      IMPLICIT NONE
 
!/ ------------------------------------------------------------------- /       
 ! Parameter list
 
           INTEGER, INTENT(IN)            :: IPT
           REAL   , INTENT(IN)            :: XPT(:), YPT(:)
           INTEGER, INTENT(OUT)           :: itout
     INTEGER, INTENT(OUT)           :: IVER(4), JVER(4)
     REAL, INTENT(OUT)              :: RD(4)
 !/ ------------------------------------------------------------------- /                 
 !local parameters
 
           DOUBLE PRECISION             :: x1, x2, x3, x
           DOUBLE PRECISION             :: y1, y2, y3, y
           DOUBLE PRECISION             :: dM1, dM2, dM3
           DOUBLE PRECISION             :: sg1, sg2, sg3
           DOUBLE PRECISION             :: s1, s2, s3
           INTEGER                      :: ITRI, I, J, K
!/S        INTEGER                      ::  IENT = 0
!/S      CALL STRACE (IENT, 'INTERPOLATION')

!
         itout = 0 
!
! coordinates of the output point 	    
!
            x=DBLE(XPT(IPT)) 
            y=DBLE(YPT(IPT))
            DO ITRI= 1, NTRI
! coordinates of the first vertex A	    
              x1=XYB(TRIGP(ITRI,1),1) 
              y1=XYB(TRIGP(ITRI,1),2)
! coordinates of the 2nd vertex B 
              x2=XYB(TRIGP(ITRI,2),1)          
              y2=XYB(TRIGP(ITRI,2),2)
!coordinates of the 3rd vertex C	    
              x3=XYB(TRIGP(ITRI,3),1)          
              y3=XYB(TRIGP(ITRI,3),2)
!evaluate squared length between the vertices and the output point	    
              dM1=(y-y1)**2+(x-x1)**2
              dM2=(y-y2)**2+(x-x2)**2
              dM3=(y-y3)**2+(x-x3)**2
!	    
              IF (dM2 > dM3) THEN 
!vector product of BC and BA	    
                sg1=(y1-y2)*(x3-x2)-(x1-x2)*(y3-y2)    
!vector product of BC and BM     
                s1= (y -y2)*(x3-x2)-(x -x2)*(y3-y2)       
              ELSE
!vector product of CB and CA        
                sg1=(y1-y3)*(x2-x3)-(x1-x3)*(y2-y3)    
!vector product of CB and CM     
                s1= (y -y3)*(x2-x3)-(x -x3)*(y2-y3)       
                END IF
              IF (dM3 > dM1) THEN 
!vector product of CA and CB	    
                sg2=(y2-y3)*(x1-x3)-(x2-x3)*(y1-y3)    
!vector product of CA and CM	       
                s2= (y -y3)*(x1-x3)-(x -x3)*(y1-y3)       
              ELSE
!vector product of AC and AB	    
                sg2=(y2-y1)*(x3-x1)-(x2-x1)*(y3-y1)    
!vector product of AC and AM	       
                s2= (y-y1) *(x3-x1)-(x-x1) *(y3-y1)       
                END IF
              IF (dM1 > dM2) THEN 
!vector product of AB and AC
                sg3=(y3-y1)*(x2-x1)-(x3-x1)*(y2-y1)
!vector product of AB and AM   
                s3= (y-y1) *(x2-x1)-(x-x1) *(y2-y1)       
              ELSE
!vector product of BA and BC	    
                sg3=(y3-y2)*(x1-x2)-(x3-x2)*(y1-y2)  
!vector product of BA and BM	         
                s3= (y-y2) *(x1-x2)-(x-x2) *(y1-y2)       
                END IF
! test if the point is within the triangle	    
            IF ((s1*sg1.GE.0).AND.(s2*sg2.GE.0).AND.(s3*sg3.GE.0)) THEN 
              itout=ITRI
              IVER(1)=TRIGP(ITRI,1)
              IVER(2)=TRIGP(ITRI,2)
              IVER(3)=TRIGP(ITRI,3)
              IVER(4)=TRIGP(ITRI,1)
              JVER(:)=1
              RD(1)=s1/sg1    ! this is the ratio of triangles areas MBC / ABC
              RD(2)=s2/sg2    ! this is the ratio of triangles areas MAC / ABC
              RD(3)=1.-RD(1)-RD(2) 
              RD(4)=0
!PRINT*,'TRI TEST:',ITOUT 
!PRINT*, TRIGP(ITOUT,1:3)
!PRINT*, IVER
!PRINT*, RD
!PRINT*, x1,x2,x3,x
!PRINT*, y1,y2,y3,y
!PRINT*, sg1,s1,sg2,s2,sg3,s3
             END IF
           END DO
! *
      RETURN
      END SUBROUTINE IS_IN_UNGRID_INTERP
!/ ------------------------------------------------------------------- / 
      SUBROUTINE UG_GRADIENTS (PARAM, DIFFX, DIFFY)
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          08-Nov-2011|
!/                  +-----------------------------------+
!/
!/    15-Nov-2007 : Origination.                        ( version 3.13 )
!/    31-Oct-2010 : Merging of 4.03 with 3.14-Ifremer   ( version 4.04 )
!/    08-Nov-2011 : Correction for zero grad. on contour( version 4.04 )
!/      
!
!  1. purpose: calculate gradients at a point via its connection.
!  2. Method : using 3D plan definition and angular redistribution
!      
!    
!
!  3. Parameters :
!     PARAM : depth or current field (indices 0 to NSEA) 
!     DIFFX :  x gradient            (indices 1 to NX)
!     DIFFY :  y gradient            (indices 1 to NX)
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3WAVE    Subr.          Actual wind wave routine
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!      This subroutine is adjusted from WWM code (Aaron Roland)

!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :     
      USE CONSTANTS
      USE W3GDATMD, ONLY : CROSSDIFF, TRIGP, NTRI, NX, NSEA, MAPFS, CLATIS, &
                           MAPSTA, ANGLE, FLAGLL,  IOBP
      IMPLICIT NONE     
      
      
      REAL, INTENT(IN)     :: PARAM(0:NSEA)
      REAL, INTENT(OUT)    :: DIFFX(:,:), DIFFY(:,:)
 
! local parameters      
      
      INTEGER              :: VERTICES(3)
      INTEGER              :: COUNTER(NX)
      REAL                 :: TMP1(3), TMP2(3)
      INTEGER              :: I, IX
      REAL                 :: VAR(3), FACT, LAT(3)
      REAL                 :: DIFFXTMP, DIFFYTMP
      
       
!initialisation step      
      COUNTER(:) = 0.
      DIFFX(:,:) = 0.              
      DIFFY(:,:) = 0. 
!
     IF (FLAGLL) THEN 
       FACT=1./(DERA*RADIUS)
     ELSE
       FACT=1.
       END IF
     DO I = 1, NTRI
       VERTICES(1) = TRIGP(I,1)
       VERTICES(2) = TRIGP(I,2)
       VERTICES(3) = TRIGP(I,3)
!
!   CLATIS is 1/COS(latitute) 
! 
       LAT(1)=CLATIS(MAPFS(1,VERTICES(1)))
       LAT(2)=CLATIS(MAPFS(1,VERTICES(2)))
       LAT(3)=CLATIS(MAPFS(1,VERTICES(2)))
      

       VAR(1) = PARAM(MAPFS(1,VERTICES(1)))* FACT*LAT(1)
       VAR(2) = PARAM(MAPFS(1,VERTICES(2)))* FACT*LAT(2)
       VAR(3) = PARAM(MAPFS(1,VERTICES(3)))* FACT*LAT(3)
     
       TMP1(:)  = CROSSDIFF(1:3, I)
       TMP2(:)  = CROSSDIFF(4:6, I)

       DIFFXTMP = DOT_PRODUCT(VAR(:),TMP1(:))
       DIFFYTMP = DOT_PRODUCT(VAR(:),TMP2(:))

! calculate global gradients via all the connection contributions.
       DIFFX(1,VERTICES(:)) = DIFFX(1,VERTICES(:)) + DIFFXTMP * ANGLE(I,:)
       DIFFY(1,VERTICES(:)) = DIFFY(1,VERTICES(:)) + DIFFYTMP * ANGLE(I,:) 
       END DO

! restore 0 on the contour 
       DO IX = 1,NX
         IF (IOBP(IX).EQ. 0 ) THEN
           DIFFX(1,IX)  =  0.     
           DIFFY(1,IX)  =  0.
           END IF
         END DO 
!
    END SUBROUTINE UG_GRADIENTS
!/ ------------------------------------------------------------------- /    
    SUBROUTINE W3NESTUG(DISTMIN,FLOK)
    USE W3ODATMD, ONLY: NBI, NDSE, ISBPI, XBPI, YBPI
    USE W3GDATMD, ONLY: NX, XYB, XGRD, YGRD, MAPSTA, MAPFS, MAPSF


    REAL, INTENT(IN)         :: DISTMIN
    LOGICAL, INTENT(INOUT)         :: FLOK

    INTEGER                   :: I, J, JMEMO, IS, IX,  N, IX1(NBI)
    REAL                      :: DIST, DIST0
!
    N = 0 
!
!1. look for input boundary point index
! warning: if land points are included as boundary points to abide by the nest
! file, their status should be -2.
!
    IX1 = 0
    ISBPI = 1
    DO IX = 1, NX
      IF (ABS(MAPSTA (1,IX)) .EQ. 2) THEN
        N = N + 1 
        IX1(N) = IX
!/T        WRITE(NDSE ,*)'ADDING BOUNDARY POINT:',N,IX
        END IF
      END DO
!
!2. Matches the model grid points (where MAPSTA = 2) with the points in nest.ww3
!   For this, we use the nearest point in the nest file.
!
    DO I = 1, NBI 
!FA: This will not work with FLAGLL=.F.  (XY grid)
      DIST0 = 360**2
      IS=1
      DO J = 1, N
        DIST=(XBPI(I)-XYB(IX1(J),1))**2+(YBPI(I)-XYB(IX1(J),2))**2
        IF (DIST.LT.DIST0) THEN 
          IS = MAPFS(1,IX1(J))
          DIST0=DIST
          JMEMO=J
          END IF
        END DO
      DIST0=SQRT(DIST0)
      IF (DIST0.LE.DISTMIN) THEN          
        ISBPI(I)=IS
!/T        WRITE(NDSE ,'(A,I6,A,I7,A,I6)') 'MATCHED BOUNDARY POINT:',I,'GRID POINT:', &
!/T                                         MAPSF(IS,1),'INDEX IN nest.ww3:', JMEMO
     ELSE
        FLOK=.TRUE.
        END IF
      END DO  
    IF ( N .NE. NBI) THEN 
      WRITE(NDSE ,900) N, NBI
      DO J=1,N
        WRITE(6,*) 'THIS POINT HAS MAPSTA=2:',ISBPI(J)  
        END DO
      ISBPI(N+1:NBI)=ISBPI(1)
      END IF
      
900 FORMAT (/' *** WAVEWATCH III ERROR IN W3IOBC : '/                &
             '     NUMBER OF MAPSTA=2 DIFFERS FROM NUMBER IN nest.ww3    '/                &
             '     CHECK nest.ww3 AND ww3_grid.inp ',2I8/)
END SUBROUTINE

!/ ------------------------------------------------------------------- /
   SUBROUTINE SETUGIOBP ( )    
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        Fabrice Ardhuin            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         23-Aug-2011 |
!/                  +-----------------------------------+
!/
!/    23-Aug-2011 : Origination.                        ( version 4.04 )
!/
!  1. Purpose :
!
!     Redefines the values of the boundary points and angle pointers
!     based on the MAPSTA array
!
!  2. Method :
!
!     
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!     Local variables.
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!

!  5. Called by :
!
!       WW3_GRID
!       W3UPTD??   forcing field update
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!
!  9. Switches :
!
!       !/S     Enable subroutine tracing.
!
!
! 10. Source code :     
!/ ------------------------------------------------------------------- /
!/
!
      USE CONSTANTS
!
!
      USE W3GDATMD, ONLY: NX, NY, NSEA, MAPSF, MAPFS, DTCFL,          &
                          NK, NTH, DTH, XFR, MAPSTA, COUNTRI,         &
                          ECOS, ESIN, SIG,  PFMOVE,IEN, COUNTOT,      &
                          NTRI, TRIGP, CCON , TRIA03, VNEIGH,         &
                          IE_CELL, POS_CELL, IOBP,IOBPD, XYB, TH,     &
                          ANGLE0, ANGLE, REFPARS, REFLC, REFLD

      USE W3ODATMD, ONLY: TBPI0, TBPIN, FLBPI
      USE W3ADATMD, ONLY: CG, CX, CY, ATRNX, ATRNY, ITIME, CFLXYMAX
      USE W3IDATMD, ONLY: FLCUR
!      USE W3ODATMD, ONLY: NDSE, NDST, FLBPI, NBI, TBPI0, TBPIN,       &
!                          ISBPI, BBPI0, BBPIN
!/S      USE W3SERVMD, ONLY: STRACE
      
      IMPLICIT NONE
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      LOGICAL                 :: REDO_ANGLE
      INTEGER                 :: ITH, IK, ISEA, IXY, IBI, FOUND    
      INTEGER                 :: IX, IY, I, J, IP, IP0, IP2, IPB, IE
      REAL                    :: CCOS, CSIN, CCURX, CCURY, THTEST 
      REAL (KIND = 8)         :: DIRMIN, DIRMAX, SHIFT, TEMPO, DIRCOAST, &
                                 DIRCOAST1, DIRCOAST2, SUMCOS1, SUMCOS2, DIRDIFF
      INTEGER                 :: SEANEIGHP(NX,15,2)
      REAL                    :: C(NX,2)
      REAL                    :: RD1, RD2
      REAL (KIND = 8)         :: X1, X2, X3, Y1, Y2, Y3
      INTEGER                 :: SEACCON(NX), SEANEIGH(NX), SEA_CELL(COUNTOT)
      INTEGER                 ::  COUNT_MAX
      INTEGER                 :: K, K2, I1, I2, I3
      INTEGER                 :: TRILAND(NTRI)
      REAL                    :: ANGLETOT(NX), ANGLETOTINV(NX)
!/ ------------------------------------------------------------------- /				     
!
! 1.  Preparations --------------------------------------------------- *
! 1.a Set constants
!      
      
!/S      CALL STRACE (IENT, 'SETUGIOBP')      
!
! Counts the number of wet neighbor nodes
!
        SEANEIGH(1:NX)=0
        SEA_CELL(:)=0
        J = 0
        DO IX = 1, NX
          DO I = 1, 2*COUNTRI
            IF (VNEIGH(IX,I).NE.0) THEN 
              IF (MAPSTA(1,VNEIGH(IX,I)).GT.0) SEANEIGH(IX)=SEANEIGH(IX)+1  ! Loop over all connected points
              !WRITE(995,*) 'TEST BOUNDARY 1:',IX,VNEIGH(IX,I),SEANEIGH(IX),CCON(IX)
              END IF 
            END DO         
          END DO
!
! Counts the number of wet neighbor triangles
!
        SEACCON(1:NX)=0
        SEANEIGHP(:,:,:)=0
        J = 0
        DO IX = 1, NX
          DO I = 1, CCON(IX)                  ! Loop over all connected Elements
             J = J + 1
             IE    = IE_CELL(J)                ! Connected Element Number
             IF (MAPSTA(1,TRIGP(IE,1)).GT.0.AND. &
                 MAPSTA(1,TRIGP(IE,2)).GT.0.AND. &
                 MAPSTA(1,TRIGP(IE,3)).GT.0) THEN 
               SEACCON(IX)=SEACCON(IX)+1
               SEA_CELL(J)=1
               END IF
!
! Used for reflection ... 
!
             DO K2=1,3      
               FOUND=0         
               DO K=1,SEANEIGHP(IX,1,1)
                  IF (SEANEIGHP(IX,K+1,1).EQ.TRIGP(IE,K2)) THEN 
                    SEANEIGHP(IX,K+1,2)=SEANEIGHP(IX,K+1,2)+1
                    FOUND=1
                    END IF
                  END DO
                IF (FOUND.EQ.0) THEN
                  SEANEIGHP(IX,1,1)=SEANEIGHP(IX,1,1)+1
                  K=SEANEIGHP(IX,1,1)
             !    IF (K.GT.13) WRITE(6,*) 'SEANEIGHP :',IX,K,K2,TRIGP(IE,K2)
                  SEANEIGHP(IX,K+1,1)=TRIGP(IE,K2)
                  SEANEIGHP(IX,K+1,2)=1
                  END IF
                END DO
! 
             END DO         
          END DO
! 
        IOBP(:)=1
        IOBPD(:,:)=1
!
! Searches for boundary points
! 
!/REF1            REFLC(1,:)= 0.
!/REF1            REFLD(:,:)= 0
!
        DO IX = 1, NX
          IF (MAPSTA(1,IX).LE.0) THEN 
            IOBP(IX)=0
            IOBPD(:,IX)=0
            END IF
          IF (SEACCON(IX) .LT. SEANEIGH(IX).AND.MAPSTA(1,IX).NE.2) THEN 
            IOBP(IX)=0
!/REF1            REFLC(1,MAPFS(1,IX))= REFPARS(1)
          !  WRITE(995,*) '@@@@ TRUE BOUNDARY:',IX,IOBP(IX),MAPSTA(1,IX),SEACCON(IX),SEANEIGH(IX),CCON(IX)
          !ELSE
          !  WRITE(995,*) '       NO BOUNDARY:',IX,IOBP(IX),MAPSTA(1,IX),SEACCON(IX),SEANEIGH(IX),CCON(IX)
            END IF    
          END DO     
!
! Now looks for excluded angles
!
        J = 0
        DO IX = 1, NX
          DIRCOAST1=-999.
          DIRCOAST2=-999.
          IF (IOBP(IX).EQ.0) IOBPD(:,IX)=0
          DO I = 1, CCON(IX)                  ! Loop over all connected Elements
            J = J + 1
            IF ((IOBP(IX).EQ.0).AND.(SEA_CELL(J).EQ.1)) THEN 
              IE    = IE_CELL(J)                ! Connected Element Number
              IP0 = POS_CELL(J)
              IP=MOD(IP0,3)+1
              IPB=MOD(IP0+1,3)+1
!
!  We are now dealing with an excluded point that is a neighbor of a boundary point
!
              X1=DBLE(XYB(TRIGP(IE,IP0),1))
              Y1=DBLE(XYB(TRIGP(IE,IP0),2))
              X2=DBLE(XYB(TRIGP(IE,IP ),1))
              Y2=DBLE(XYB(TRIGP(IE,IP ),2))
              X3=DBLE(XYB(TRIGP(IE,IPB),1))
              Y3=DBLE(XYB(TRIGP(IE,IPB),2))
 
              CALL line_angle( x2, y2, x1, y1, DIRMIN )
              CALL line_angle( x3, y3, x1, y1, DIRMAX )
                IF (DIRMAX.LT.DIRMIN) CALL d_swap(DIRMIN,DIRMAX)
                SHIFT=0
                IF (ABS(DIRMAX-DIRMIN).GT.PI) THEN 
                  TEMPO=DIRMAX
                  DIRMAX=DIRMIN+DBLE(PI)
                  DIRMIN=TEMPO-DBLE(PI)
                  SHIFT=PI
                  END IF
                DO ITH=1, NTH
                  THTEST=MOD(TH(ITH)+SHIFT,DBLE(TPI))
                  IF ((THTEST.GE.DIRMIN) .AND.   &
                     (THTEST.LE.DIRMAX)) THEN
                    IOBPD(ITH,IX) = 1
                    !WRITE(995,*) 'IOBPD OUT:',IX,IE,ITH,IOBP(IX),TH(ITH)*RADE,DIRMIN*RADE,DIRMAX*RADE
                    END IF
                  END DO 
                END IF
              END DO       !  I = 1, CCON(IX) 
            END DO

!/REF1 ! 
!/REF1 ! Finds the shoreline direction 
!/REF1 !
!/REF1          DO IX = 1, NX
!/REF1            FOUND=0
!/REF1            DO K=1,SEANEIGHP(IX,1,1)
!/REF1              IF (SEANEIGHP(IX,K+1,2).EQ.1) THEN 
!/REF1                IF (FOUND.EQ.0) THEN 
!/REF1                  IP=SEANEIGHP(IX,K+1,1)
!/REF1                  FOUND=FOUND+1
!/REF1                ELSE 
!/REF1                  IPB=SEANEIGHP(IX,K+1,1)
!/REF1                  END IF
!/REF1                END IF
!/REF1              END DO
!/REF1            IF (FOUND.GT.2) WRITE(6,*) 'WARNING: POINT ',IX,'HAS MORE THAN 2 CONNECTED SHORELINE SEGMENTS.'
!/REF1            X1=DBLE(XYB(IX,1))
!/REF1            Y1=DBLE(XYB(IX,2))
!/REF1            X2=DBLE(XYB(IP,1))
!/REF1            Y2=DBLE(XYB(IP,2))
!/REF1            X3=DBLE(XYB(IPB,1))
!/REF1            Y3=DBLE(XYB(IPB,2))
 
!/REF1            CALL line_angle( x2, y2, x1, y1, DIRCOAST1 )
!/REF1            CALL line_angle( x3, y3, x1, y1, DIRCOAST2 )
!
!/REF1             SUMCOS1=0. 
!/REF1             SUMCOS2=0. 
!/REF1             DIRCOAST=0.5*(DIRCOAST1+DIRCOAST2)

!/REF1             DO ITH=1, NTH
!/REF1               IF (IOBPD(ITH,IX).EQ.0) THEN 
!/REF1                 SUMCOS1=SUMCOS1+COS(DIRCOAST-TH(ITH))
!/REF1                 SUMCOS2=SUMCOS2+COS(DIRCOAST+PI-TH(ITH))
!/REF1        !        WRITE(995,*) 'DIR COAST:',IX,ITH,SUMCOS1, SUMCOS2, DIRCOAST
!/REF1                 END IF
!/REF1               END DO
!/REF1 ! Keep the direction DIRCOAST if SUMCOS1 > SUMCOS2, otherwise adds PI
!/REF1             IF (SUMCOS1.GT.SUMCOS2) DIRCOAST=DIRCOAST+PI
!/REF1 ! NOTE: because the reflection was first implemented on regular grids, shoreline dirs. were discretized
!/REF1 ! NOTE: Now, this is a pity not to use the full resolution of directions for triangle-based meshes
!/REF1               REFLD(1,MAPFS(1,IX)) = 1+MOD(NINT(DIRCOAST/DTH),NTH)
!/REF1               DIRDIFF=ABS(DIRCOAST1-DIRCOAST)
!/REF1               IF (DIRDIFF.GT.PI) DIRDIFF=ABS(DIRDIFF-TPI)
!/REF1               REFLD(2,MAPFS(1,IX)) = 4-MAX(2,NINT(DIRDIFF/(0.25*PI)))
!/REF1               !These X and Y lengths of boundary are not used now... 
!/REF1               !UG_BOUNDL(1,IX) = ABS(X3-X2)*0.5* DERA * RADIUS
!/REF1               !UG_BOUNDL(2,IX) = ABS(Y3-Y2)*0.5* DERA * RADIUS
!/REF1               !WRITE(995,'(A,3I8,4F6.1,2I4,2F10.1)') 'DIR COAST:',IX,IP,IPB,DIRCOAST*RADE,DIRCOAST1*RADE,  &
!/REF1               !         DIRCOAST2*RADE, DIRDIFF*RADE, REFLD(1:2,MAPFS(1,IX))  !, UG_BOUNDL(1:2,IX)
!/REF1          END DO
!
! Recomputes the angles used in the gradients estimation 
!
!REDO_ANGLE = 1
!      IF (REDO_ANGLE) THEN 
!
! MAP FOR LAND POINTS    
! 
       TRILAND(:) = 0
       K = 0
       DO IE = 1, NTRI
         I1 = TRIGP(IE,1)
         I2 = TRIGP(IE,2)
         I3 = TRIGP(IE,3)
!
!! MAP FOR TRIANGLE STATUS: 
!     TRILAND=0     ->sea triangle
!     TRILAND=1 , 2 -> contour
!     TRILAND=3     -> land

     
          IF ((MAPSTA(1,I1).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          IF ((MAPSTA(1,I2).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          IF ((MAPSTA(1,I3).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          END DO
!
! Now calculate the angle of action of a vertex (see gradients in w3updtmd.ftn)
! If a triangle is connected to the contour, the angle of each vertex is not
! taken into account when interpolating gradients.
!
        ANGLETOT(:) = 0. ! TPI
        DO IE = 1, NTRI 
          TRILAND(IE)=MIN(TRILAND(IE),1)
          I1 = TRIGP(IE,1)
          I2 = TRIGP(IE,2)
          I3 = TRIGP(IE,3) 
          IF (TRILAND(IE) .EQ. 0) THEN  
            ANGLETOT(I1) = ANGLETOT(I1) + ANGLE0(IE,1)
            ANGLETOT(I2) = ANGLETOT(I2) + ANGLE0(IE,2)
            ANGLETOT(I3) = ANGLETOT(I3) + ANGLE0(IE,3)
            END IF
          END DO

      DO IP = 1, NX
        IF (ANGLETOT(IP) .NE. 0)  THEN 
           ANGLETOTINV(IP) = 1./ANGLETOT(IP)
        ELSE 
          ANGLETOTINV(IP) = 0.
          END IF
        END DO
!
      DO IE = 1, NTRI
        I1 = TRIGP(IE,1)
        I2 = TRIGP(IE,2)
        I3 = TRIGP(IE,3) 
!
! Angles for land triangles are set to zero
!
        ANGLE(IE,1) = ANGLE0(IE,1)*ANGLETOTINV(I1)*(1-TRILAND(IE))
        ANGLE(IE,2) = ANGLE0(IE,2)*ANGLETOTINV(I2)*(1-TRILAND(IE))
        ANGLE(IE,3) = ANGLE0(IE,3)*ANGLETOTINV(I3)*(1-TRILAND(IE))
        !WRITE(998,*) 'IE, ANGLE:',IE,I1,I2,I3,ANGLE(IE,1:3),ANGLETOT(I1)*RADE,TRILAND(IE)

        END DO

!       END IF

      CALL DIFFERENCE

      RETURN    
      END SUBROUTINE SETUGIOBP
!/ ------------------------------------------------------------------- /

!C
!C******************************************************************************
!C        
      subroutine line_angle( x1, y1, x2, y2, angle )
        implicit none
        real (kind = 8) x1, y1, x2, y2
        real (kind = 8) angle
        real (kind = 8) dx, dy
        
        dx = x2 - x1
        dy = y2 - y1
        angle = atan2( dy, dx )
        if ( angle < 0.0d0 ) angle = 8.0d0 * atan(1.0d0) + angle
        
        return
      end subroutine       
!C
!C******************************************************************************
!C
      subroutine d_swap( a, b )
        implicit none
        real (kind = 8) a, b
        real (kind = 8) dtmp
        
        dtmp = a
        a = b
        b = dtmp
        
        return
      end subroutine                                 
!/      
END MODULE W3TRIAMD
