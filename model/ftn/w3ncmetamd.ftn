MODULE W3NCMETAMD
! Storage of attrbute name/value pairs using a linked list.
! Attribute values can be stored as a float*4, int*4 or character
! array. All data is stored internally as a BYTE array using
! the TRANSFER function.
! Chris Bunney. UK Met Office.

    LOGICAL :: DEBUG = .True.

    TYPE METALIST_T
      TYPE(METANODE_T), POINTER :: root, head
    END TYPE METALIST_T

    TYPE METANODE_T
      CHARACTER(LEN=128) :: attname
      INTEGER(KIND=1), ALLOCATABLE :: attval(:)
      CHARACTER :: type

      TYPE(METANODE_T), POINTER :: NEXT
    END TYPE METANODE_T

    TYPE(METANODE_T), POINTER :: ROOT


    INTERFACE LIST_APPEND
      MODULE PROCEDURE LIST_APPEND_C
      MODULE PROCEDURE LIST_APPEND_I
      MODULE PROCEDURE LIST_APPEND_F
    END INTERFACE LIST_APPEND

    CONTAINS 


    FUNCTION LIST_NEW()
      ! Returns a fresh list with internals nullified.
      TYPE(METALIST_T) :: LIST_NEW
      NULLIFY(LIST_NEW%root)
      NULLIFY(LIST_NEW%head)
      list_new%head => list_new%root
    END FUNCTION LIST_NEW


    FUNCTION LIST_APPEND_NODE(list) 
      ! Appends a new node to the list. If list is empty, will add node at root.
      TYPE(METALIST_T), INTENT(INOUT) :: list
      TYPE(METANODE_T), POINTER :: LIST_APPEND_NODE
      ALLOCATE(LIST_APPEND_NODE)
      IF(.NOT. ASSOCIATED(list%root)) THEN
        IF(DEBUG) PRINT*,'Empty list - creating root node'
        list%root => LIST_APPEND_NODE
        list%head => LIST_APPEND_NODE
      ELSE      
        IF(DEBUG) print*,'Appending node to end of list'
        list%head%next => LIST_APPEND_NODE
        list%head => list%head%next
      ENDIF
      NULLIFY(LIST_APPEND_NODE%next)
    END FUNCTION


    SUBROUTINE LIST_APPEND_C(list, attname, attval)
      ! Add a string/character attribute to the list
      TYPE(METALIST_T), INTENT(INOUT) :: list
      TYPE(METANODE_T), POINTER :: p
      CHARACTER(*), INTENT(IN) :: attname, attval

      IF(DEBUG) PRINT*,'Adding character data'
      p => LIST_APPEND_NODE(list)

      p%attname = attname
      ALLOCATE(p%attval(LEN_TRIM(attval)))
      p%attval = TRANSFER(TRIM(attval), p%attval)
      p%type = 'c'
    END SUBROUTINE

    SUBROUTINE LIST_APPEND_I(list, attname, attval)
      ! Add a integer attribute to the list
      TYPE(METALIST_T), INTENT(INOUT) :: list
      TYPE(METANODE_T), POINTER :: p
      CHARACTER(*), INTENT(IN) :: attname
      INTEGER(KIND=4), INTENT(IN) :: attval

      IF(DEBUG) PRINT*,'Adding integer data'
      p => LIST_APPEND_NODE(list)

      p%attname = attname
      ALLOCATE(p%attval(4))
      p%attval = TRANSFER(attval, p%attval)
      p%type = 'i'
    END SUBROUTINE

    SUBROUTINE LIST_APPEND_F(list, attname, attval)
      ! Add a float/real attribute to the list
      TYPE(METALIST_T), INTENT(INOUT) :: list
      TYPE(METANODE_T), POINTER :: p
      CHARACTER(*), INTENT(IN) :: attname
      REAL(KIND=4), INTENT(IN) :: attval

      IF(DEBUG) PRINT*,'Adding float data'
      p => LIST_APPEND_NODE(list)

      p%attname = attname
      ALLOCATE(p%attval(4))
      p%attval = TRANSFER(attval, p%attval)
      p%type = 'f'
    END SUBROUTINE

    
    FUNCTION GET_CHAR(listitem) RESULT(VALUE)
      TYPE(METANODE_T), POINTER :: listitem
      CHARACTER(LEN=128) :: VALUE
      VALUE = transfer(listitem%attval, VALUE)
      VALUE = VALUE(1:SIZE(listitem%attval)) ! Needed to ensure buffer is "terminated" properly.
    END FUNCTION GET_CHAR


    FUNCTION GET_INT(listitem) RESULT(VALUE)
      TYPE(METANODE_T), POINTER :: listitem
      INTEGER(KIND=4) :: VALUE
      VALUE = transfer(listitem%attval, 1_4)
    END FUNCTION GET_INT


    FUNCTION GET_FLOAT(listitem) RESULT(VALUE)
      TYPE(METANODE_T), POINTER :: listitem
      REAL(KIND=4) :: VALUE
      VALUE = transfer(listitem%attval, 1.0_4)
    END FUNCTION GET_FLOAT


    SUBROUTINE LIST_FIND_ATTR(list, attname, item, err)
      TYPE(METALIST_T), INTENT(IN) :: list
      CHARACTER(*), INTENT(IN) :: attname
      TYPE(METANODE_T), INTENT(OUT), POINTER :: item
      INTEGER, INTENT(OUT) :: err

      TYPE(METANODE_T), POINTER :: this
      item => list%root

      DO
        IF(TRIM(item%attname) == TRIM(attname)) THEN
          err = 0
          return
        ENDIF
        
        IF(.NOT. ASSOCIATED(item%next)) EXIT
        item => item%next
      ENDDO

      ! not found
      err = 1
      NULLIFY(item)
    END SUBROUTINE LIST_FIND_ATTR


    SUBROUTINE LIST_DEALLOCATE(root)
      ! Traverse a list and free all allocated memory, including the list itself.
      TYPE(METANODE_T), INTENT(IN), POINTER :: root
      TYPE(METANODE_T), POINTER :: next, this

      this => root
      DO
        IF(.NOT. ASSOCIATED(this)) EXIT

        ! Free data storage
        IF(ALLOCATED(this%attval)) DEALLOCATE(this%attval)
        next => this%next
        DEALLOCATE(this)
        this => next
      ENDDO
    END SUBROUTINE LIST_DEALLOCATE
  
END MODULE W3NCMETAMD